/*
 * Numbers.java - Class providing number theoretic functions and mathematical constants
 *
 * Copyright (C) 2007-2012 Andreas de Vries
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, see http://www.gnu.org/licenses
 * or write to the Free Software Foundation,Inc., 51 Franklin Street,
 * Fifth Floor, Boston, MA 02110-1301  USA
 * 
 * As a special exception, the copyright holders of this program give you permission 
 * to link this program with independent modules to produce an executable, 
 * regardless of the license terms of these independent modules, and to copy and 
 * distribute the resulting executable under terms of your choice, provided that 
 * you also meet, for each linked independent module, the terms and conditions of 
 * the license of that module. An independent module is a module which is not derived 
 * from or based on this program. If you modify this program, you may extend 
 * this exception to your version of the program, but you are not obligated to do so. 
 * If you do not wish to do so, delete this exception statement from your version.
 */
package org.mathIT.numbers;

import static java.lang.Math.*;
import java.math.BigInteger;
import java.util.ArrayList;
import java.util.LinkedList;

/**
 * This class provides basic number theoretic functions.
 * @author  Andreas de Vries
 * @version 1.1
 */
public class Numbers {
   // Suppresses default constructor, ensuring non-instantiability.
   private Numbers() {
   }

   /** Euler-Mascheroni constant &#947; = 0.577215664901532860605. 
    *  According to general mathematical conventions, it is written in small letters.
    *  @see #GAMMA
    *  @see BigNumbers#GAMMA
    */
   public static final double gamma = 0.577215664901532860605;
   /** Euler-Mascheroni constant &#947; = 0.577215664901532860605.
    *  @see BigNumbers#GAMMA
    */
   public static final double GAMMA = 0.577215664901532860605;
   /** constant representing the square root of 2.
    *  @see BigNumbers#SQRT_TWO
    */
   public static final double SQRT2 = 1.4142135623730951; // = Math.sqrt(2);
   /** constant representing the square root of 3.
    */
   public static final double SQRT3 = 1.7320508075688772; // = Math.sqrt(3);
   /** Square root of 1/2.
    *  @see BigNumbers#SQRT_ONE_HALF
    */
   public static final double SQRT_1_2 = 0.7071067811865476; // = 1 / Math.sqrt(2)
   /** The constant 2&#x03C0;/360, the ratio of 1 radians per degree.
    *  @see java.lang.Math#PI
    *  @see BigNumbers#RADIANS
    */
   public static final double RADIANS = 0.017453292519943295; // = 2 * Math.PI / 360
   /** The value of the Riemann Zeta function &#x03B6;(3). 
    *  See M. Abramowitz and I. A. Stegun: <i>Handbook of Mathematical Functions</i>, p. 811.
    *  @see BigNumbers#ZETA_3
    */
   public static final double ZETA_3  = 1.20205690315959428540;
   /** The value of the Riemann Zeta function &#x03B6;(5). 
    *  See M. Abramowitz and I. A. Stegun: <i>Handbook of Mathematical Functions</i>, p. 811.
    *  @see BigNumbers#ZETA_5
    */
   public static final double ZETA_5  = 1.03692775514336992633;
   /** The value of the Riemann Zeta function &#x03B6;(7). 
    *  See M. Abramowitz and I. A. Stegun: <i>Handbook of Mathematical Functions</i>, p. 811.
    *  @see BigNumbers#ZETA_7
    */
   public static final double ZETA_7  = 1.00834927738192282684;
   /** The value of the Riemann Zeta function &#x03B6;(9). 
    *  See M. Abramowitz and I. A. Stegun: <i>Handbook of Mathematical Functions</i>, p. 811.
    *  @see BigNumbers#ZETA_9
    */
   public static final double ZETA_9  = 1.00200839282608221442;
   /** The value of the Riemann Zeta function &#x03B6;(11). 
    *  See M. Abramowitz and I. A. Stegun: <i>Handbook of Mathematical Functions</i>, p. 811.
    *  @see BigNumbers#ZETA_11
    */
   public static final double ZETA_11 = 1.00049418860411946456;
   /** The value of the Riemann Zeta function &#x03B6;(13). 
    *  See M. Abramowitz and I. A. Stegun: <i>Handbook of Mathematical Functions</i>, p. 811.
    *  @see BigNumbers#ZETA_13
    */
   public static final double ZETA_13 = 1.00012271334757848915;
   /** The value of the Riemann Zeta function &#x03B6;(15). 
    *  See M. Abramowitz and I. A. Stegun: <i>Handbook of Mathematical Functions</i>, p. 811.
    *  @see BigNumbers#ZETA_15
    */
   public static final double ZETA_15 = 1.00003058823630702049;
   /** The value of the Riemann Zeta function &#x03B6;(17). 
    *  See M. Abramowitz and I. A. Stegun: <i>Handbook of Mathematical Functions</i>, p. 811.
    *  @see BigNumbers#ZETA_17
    */
   public static final double ZETA_17 = 1.00000763719763789976;
   /** The value of the Riemann Zeta function &#x03B6;(19). 
    *  See M. Abramowitz and I. A. Stegun: <i>Handbook of Mathematical Functions</i>, p. 811.
    *  @see BigNumbers#ZETA_19
    */
   public static final double ZETA_19 = 1.00000190821271655394;
   /** The value of the Riemann Zeta function &#x03B6;(21). 
    *  See M. Abramowitz and I. A. Stegun: <i>Handbook of Mathematical Functions</i>, p. 811.
    *  @see BigNumbers#ZETA_21
    */
   public static final double ZETA_21 = 1.00000047693298678781;
   /** The value of the Riemann Zeta function &#x03B6;(23). 
    *  See M. Abramowitz and I. A. Stegun: <i>Handbook of Mathematical Functions</i>, p. 811.
    *  @see BigNumbers#ZETA_23
    */
   public static final double ZETA_23 = 1.00000011921992596531;
   /** The value of the Riemann Zeta function &#x03B6;(25). 
    *  See M. Abramowitz and I. A. Stegun: <i>Handbook of Mathematical Functions</i>, p. 811.
    *  @see BigNumbers#ZETA_25
    */
   public static final double ZETA_25 = 1.00000002980350351465;

   /**
    *  Array containing the binomial coefficients (<i>n</i> over <i>k</i>) 
    *  = <code>binomial</code>[<i>n</i>][<i>k</i>] for
    *  0 &#x2264; <i>n</i>, <i>k</i> &#x2264; 66.
    *  Here <code>binomial</code>[<i>n</i>][<i>k</i>] = 0 if <i>n</i> &lt; <i>k</i>.
    */
    public static final long[][] binomial = {
      {1L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L},
      {1L,1L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L},
      {1L,2L,1L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L},
      {1L,3L,3L,1L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L},
      {1L,4L,6L,4L,1L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L},
      {1L,5L,10L,10L,5L,1L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L},
      {1L,6L,15L,20L,15L,6L,1L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L},
      {1L,7L,21L,35L,35L,21L,7L,1L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L},
      {1L,8L,28L,56L,70L,56L,28L,8L,1L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L},
      {1L,9L,36L,84L,126L,126L,84L,36L,9L,1L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L},
      {1L,10L,45L,120L,210L,252L,210L,120L,45L,10L,1L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L},
      {1L,11L,55L,165L,330L,462L,462L,330L,165L,55L,11L,1L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L},
      {1L,12L,66L,220L,495L,792L,924L,792L,495L,220L,66L,12L,1L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L},
      {1L,13L,78L,286L,715L,1287L,1716L,1716L,1287L,715L,286L,78L,13L,1L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L},
      {1L,14L,91L,364L,1001L,2002L,3003L,3432L,3003L,2002L,1001L,364L,91L,14L,1L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L},
      {1L,15L,105L,455L,1365L,3003L,5005L,6435L,6435L,5005L,3003L,1365L,455L,105L,15L,1L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L},
      {1L,16L,120L,560L,1820L,4368L,8008L,11440L,12870L,11440L,8008L,4368L,1820L,560L,120L,16L,1L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L},
      {1L,17L,136L,680L,2380L,6188L,12376L,19448L,24310L,24310L,19448L,12376L,6188L,2380L,680L,136L,17L,1L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L},
      {1L,18L,153L,816L,3060L,8568L,18564L,31824L,43758L,48620L,43758L,31824L,18564L,8568L,3060L,816L,153L,18L,1L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L},
      {1L,19L,171L,969L,3876L,11628L,27132L,50388L,75582L,92378L,92378L,75582L,50388L,27132L,11628L,3876L,969L,171L,19L,1L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L},
      {1L,20L,190L,1140L,4845L,15504L,38760L,77520L,125970L,167960L,184756L,167960L,125970L,77520L,38760L,15504L,4845L,1140L,190L,20L,1L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L},
      {1L,21L,210L,1330L,5985L,20349L,54264L,116280L,203490L,293930L,352716L,352716L,293930L,203490L,116280L,54264L,20349L,5985L,1330L,210L,21L,1L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L},
      {1L,22L,231L,1540L,7315L,26334L,74613L,170544L,319770L,497420L,646646L,705432L,646646L,497420L,319770L,170544L,74613L,26334L,7315L,1540L,231L,22L,1L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L},
      {1L,23L,253L,1771L,8855L,33649L,100947L,245157L,490314L,817190L,1144066L,1352078L,1352078L,1144066L,817190L,490314L,245157L,100947L,33649L,8855L,1771L,253L,23L,1L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L},
      {1L,24L,276L,2024L,10626L,42504L,134596L,346104L,735471L,1307504L,1961256L,2496144L,2704156L,2496144L,1961256L,1307504L,735471L,346104L,134596L,42504L,10626L,2024L,276L,24L,1L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L},
      {1L,25L,300L,2300L,12650L,53130L,177100L,480700L,1081575L,2042975L,3268760L,4457400L,5200300L,5200300L,4457400L,3268760L,2042975L,1081575L,480700L,177100L,53130L,12650L,2300L,300L,25L,1L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L},
      {1L,26L,325L,2600L,14950L,65780L,230230L,657800L,1562275L,3124550L,5311735L,7726160L,9657700L,10400600L,9657700L,7726160L,5311735L,3124550L,1562275L,657800L,230230L,65780L,14950L,2600L,325L,26L,1L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L},
      {1L,27L,351L,2925L,17550L,80730L,296010L,888030L,2220075L,4686825L,8436285L,13037895L,17383860L,20058300L,20058300L,17383860L,13037895L,8436285L,4686825L,2220075L,888030L,296010L,80730L,17550L,2925L,351L,27L,1L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L},
      {1L,28L,378L,3276L,20475L,98280L,376740L,1184040L,3108105L,6906900L,13123110L,21474180L,30421755L,37442160L,40116600L,37442160L,30421755L,21474180L,13123110L,6906900L,3108105L,1184040L,376740L,98280L,20475L,3276L,378L,28L,1L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L},
      {1L,29L,406L,3654L,23751L,118755L,475020L,1560780L,4292145L,10015005L,20030010L,34597290L,51895935L,67863915L,77558760L,77558760L,67863915L,51895935L,34597290L,20030010L,10015005L,4292145L,1560780L,475020L,118755L,23751L,3654L,406L,29L,1L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L},
      {1L,30L,435L,4060L,27405L,142506L,593775L,2035800L,5852925L,14307150L,30045015L,54627300L,86493225L,119759850L,145422675L,155117520L,145422675L,119759850L,86493225L,54627300L,30045015L,14307150L,5852925L,2035800L,593775L,142506L,27405L,4060L,435L,30L,1L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L},
      {1L,31L,465L,4495L,31465L,169911L,736281L,2629575L,7888725L,20160075L,44352165L,84672315L,141120525L,206253075L,265182525L,300540195L,300540195L,265182525L,206253075L,141120525L,84672315L,44352165L,20160075L,7888725L,2629575L,736281L,169911L,31465L,4495L,465L,31L,1L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L},
      {1L,32L,496L,4960L,35960L,201376L,906192L,3365856L,10518300L,28048800L,64512240L,129024480L,225792840L,347373600L,471435600L,565722720L,601080390L,565722720L,471435600L,347373600L,225792840L,129024480L,64512240L,28048800L,10518300L,3365856L,906192L,201376L,35960L,4960L,496L,32L,1L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L},
      {1L,33L,528L,5456L,40920L,237336L,1107568L,4272048L,13884156L,38567100L,92561040L,193536720L,354817320L,573166440L,818809200L,1037158320L,1166803110L,1166803110L,1037158320L,818809200L,573166440L,354817320L,193536720L,92561040L,38567100L,13884156L,4272048L,1107568L,237336L,40920L,5456L,528L,33L,1L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L},
      {1L,34L,561L,5984L,46376L,278256L,1344904L,5379616L,18156204L,52451256L,131128140L,286097760L,548354040L,927983760L,1391975640L,1855967520L,2203961430L,2333606220L,2203961430L,1855967520L,1391975640L,927983760L,548354040L,286097760L,131128140L,52451256L,18156204L,5379616L,1344904L,278256L,46376L,5984L,561L,34L,1L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L},
      {1L,35L,595L,6545L,52360L,324632L,1623160L,6724520L,23535820L,70607460L,183579396L,417225900L,834451800L,1476337800L,2319959400L,3247943160L,4059928950L,4537567650L,4537567650L,4059928950L,3247943160L,2319959400L,1476337800L,834451800L,417225900L,183579396L,70607460L,23535820L,6724520L,1623160L,324632L,52360L,6545L,595L,35L,1L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L},
      {1L,36L,630L,7140L,58905L,376992L,1947792L,8347680L,30260340L,94143280L,254186856L,600805296L,1251677700L,2310789600L,3796297200L,5567902560L,7307872110L,8597496600L,9075135300L,8597496600L,7307872110L,5567902560L,3796297200L,2310789600L,1251677700L,600805296L,254186856L,94143280L,30260340L,8347680L,1947792L,376992L,58905L,7140L,630L,36L,1L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L},
      {1L,37L,666L,7770L,66045L,435897L,2324784L,10295472L,38608020L,124403620L,348330136L,854992152L,1852482996L,3562467300L,6107086800L,9364199760L,12875774670L,15905368710L,17672631900L,17672631900L,15905368710L,12875774670L,9364199760L,6107086800L,3562467300L,1852482996L,854992152L,348330136L,124403620L,38608020L,10295472L,2324784L,435897L,66045L,7770L,666L,37L,1L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L},
      {1L,38L,703L,8436L,73815L,501942L,2760681L,12620256L,48903492L,163011640L,472733756L,1203322288L,2707475148L,5414950296L,9669554100L,15471286560L,22239974430L,28781143380L,33578000610L,35345263800L,33578000610L,28781143380L,22239974430L,15471286560L,9669554100L,5414950296L,2707475148L,1203322288L,472733756L,163011640L,48903492L,12620256L,2760681L,501942L,73815L,8436L,703L,38L,1L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L},
      {1L,39L,741L,9139L,82251L,575757L,3262623L,15380937L,61523748L,211915132L,635745396L,1676056044L,3910797436L,8122425444L,15084504396L,25140840660L,37711260990L,51021117810L,62359143990L,68923264410L,68923264410L,62359143990L,51021117810L,37711260990L,25140840660L,15084504396L,8122425444L,3910797436L,1676056044L,635745396L,211915132L,61523748L,15380937L,3262623L,575757L,82251L,9139L,741L,39L,1L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L},
      {1L,40L,780L,9880L,91390L,658008L,3838380L,18643560L,76904685L,273438880L,847660528L,2311801440L,5586853480L,12033222880L,23206929840L,40225345056L,62852101650L,88732378800L,113380261800L,131282408400L,137846528820L,131282408400L,113380261800L,88732378800L,62852101650L,40225345056L,23206929840L,12033222880L,5586853480L,2311801440L,847660528L,273438880L,76904685L,18643560L,3838380L,658008L,91390L,9880L,780L,40L,1L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L},
      {1L,41L,820L,10660L,101270L,749398L,4496388L,22481940L,95548245L,350343565L,1121099408L,3159461968L,7898654920L,17620076360L,35240152720L,63432274896L,103077446706L,151584480450L,202112640600L,244662670200L,269128937220L,269128937220L,244662670200L,202112640600L,151584480450L,103077446706L,63432274896L,35240152720L,17620076360L,7898654920L,3159461968L,1121099408L,350343565L,95548245L,22481940L,4496388L,749398L,101270L,10660L,820L,41L,1L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L},
      {1L,42L,861L,11480L,111930L,850668L,5245786L,26978328L,118030185L,445891810L,1471442973L,4280561376L,11058116888L,25518731280L,52860229080L,98672427616L,166509721602L,254661927156L,353697121050L,446775310800L,513791607420L,538257874440L,513791607420L,446775310800L,353697121050L,254661927156L,166509721602L,98672427616L,52860229080L,25518731280L,11058116888L,4280561376L,1471442973L,445891810L,118030185L,26978328L,5245786L,850668L,111930L,11480L,861L,42L,1L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L},
      {1L,43L,903L,12341L,123410L,962598L,6096454L,32224114L,145008513L,563921995L,1917334783L,5752004349L,15338678264L,36576848168L,78378960360L,151532656696L,265182149218L,421171648758L,608359048206L,800472431850L,960566918220L,1052049481860L,1052049481860L,960566918220L,800472431850L,608359048206L,421171648758L,265182149218L,151532656696L,78378960360L,36576848168L,15338678264L,5752004349L,1917334783L,563921995L,145008513L,32224114L,6096454L,962598L,123410L,12341L,903L,43L,1L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L},
      {1L,44L,946L,13244L,135751L,1086008L,7059052L,38320568L,177232627L,708930508L,2481256778L,7669339132L,21090682613L,51915526432L,114955808528L,229911617056L,416714805914L,686353797976L,1029530696964L,1408831480056L,1761039350070L,2012616400080L,2104098963720L,2012616400080L,1761039350070L,1408831480056L,1029530696964L,686353797976L,416714805914L,229911617056L,114955808528L,51915526432L,21090682613L,7669339132L,2481256778L,708930508L,177232627L,38320568L,7059052L,1086008L,135751L,13244L,946L,44L,1L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L},
      {1L,45L,990L,14190L,148995L,1221759L,8145060L,45379620L,215553195L,886163135L,3190187286L,10150595910L,28760021745L,73006209045L,166871334960L,344867425584L,646626422970L,1103068603890L,1715884494940L,2438362177020L,3169870830126L,3773655750150L,4116715363800L,4116715363800L,3773655750150L,3169870830126L,2438362177020L,1715884494940L,1103068603890L,646626422970L,344867425584L,166871334960L,73006209045L,28760021745L,10150595910L,3190187286L,886163135L,215553195L,45379620L,8145060L,1221759L,148995L,14190L,990L,45L,1L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L},
      {1L,46L,1035L,15180L,163185L,1370754L,9366819L,53524680L,260932815L,1101716330L,4076350421L,13340783196L,38910617655L,101766230790L,239877544005L,511738760544L,991493848554L,1749695026860L,2818953098830L,4154246671960L,5608233007146L,6943526580276L,7890371113950L,8233430727600L,7890371113950L,6943526580276L,5608233007146L,4154246671960L,2818953098830L,1749695026860L,991493848554L,511738760544L,239877544005L,101766230790L,38910617655L,13340783196L,4076350421L,1101716330L,260932815L,53524680L,9366819L,1370754L,163185L,15180L,1035L,46L,1L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L},
      {1L,47L,1081L,16215L,178365L,1533939L,10737573L,62891499L,314457495L,1362649145L,5178066751L,17417133617L,52251400851L,140676848445L,341643774795L,751616304549L,1503232609098L,2741188875414L,4568648125690L,6973199770790L,9762479679106L,12551759587422L,14833897694226L,16123801841550L,16123801841550L,14833897694226L,12551759587422L,9762479679106L,6973199770790L,4568648125690L,2741188875414L,1503232609098L,751616304549L,341643774795L,140676848445L,52251400851L,17417133617L,5178066751L,1362649145L,314457495L,62891499L,10737573L,1533939L,178365L,16215L,1081L,47L,1L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L},
      {1L,48L,1128L,17296L,194580L,1712304L,12271512L,73629072L,377348994L,1677106640L,6540715896L,22595200368L,69668534468L,192928249296L,482320623240L,1093260079344L,2254848913647L,4244421484512L,7309837001104L,11541847896480L,16735679449896L,22314239266528L,27385657281648L,30957699535776L,32247603683100L,30957699535776L,27385657281648L,22314239266528L,16735679449896L,11541847896480L,7309837001104L,4244421484512L,2254848913647L,1093260079344L,482320623240L,192928249296L,69668534468L,22595200368L,6540715896L,1677106640L,377348994L,73629072L,12271512L,1712304L,194580L,17296L,1128L,48L,1L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L},
      {1L,49L,1176L,18424L,211876L,1906884L,13983816L,85900584L,450978066L,2054455634L,8217822536L,29135916264L,92263734836L,262596783764L,675248872536L,1575580702584L,3348108992991L,6499270398159L,11554258485616L,18851684897584L,28277527346376L,39049918716424L,49699896548176L,58343356817424L,63205303218876L,63205303218876L,58343356817424L,49699896548176L,39049918716424L,28277527346376L,18851684897584L,11554258485616L,6499270398159L,3348108992991L,1575580702584L,675248872536L,262596783764L,92263734836L,29135916264L,8217822536L,2054455634L,450978066L,85900584L,13983816L,1906884L,211876L,18424L,1176L,49L,1L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L},
      {1L,50L,1225L,19600L,230300L,2118760L,15890700L,99884400L,536878650L,2505433700L,10272278170L,37353738800L,121399651100L,354860518600L,937845656300L,2250829575120L,4923689695575L,9847379391150L,18053528883775L,30405943383200L,47129212243960L,67327446062800L,88749815264600L,108043253365600L,121548660036300L,126410606437752L,121548660036300L,108043253365600L,88749815264600L,67327446062800L,47129212243960L,30405943383200L,18053528883775L,9847379391150L,4923689695575L,2250829575120L,937845656300L,354860518600L,121399651100L,37353738800L,10272278170L,2505433700L,536878650L,99884400L,15890700L,2118760L,230300L,19600L,1225L,50L,1L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L},
      {1L,51L,1275L,20825L,249900L,2349060L,18009460L,115775100L,636763050L,3042312350L,12777711870L,47626016970L,158753389900L,476260169700L,1292706174900L,3188675231420L,7174519270695L,14771069086725L,27900908274925L,48459472266975L,77535155627160L,114456658306760L,156077261327400L,196793068630200L,229591913401900L,247959266474052L,247959266474052L,229591913401900L,196793068630200L,156077261327400L,114456658306760L,77535155627160L,48459472266975L,27900908274925L,14771069086725L,7174519270695L,3188675231420L,1292706174900L,476260169700L,158753389900L,47626016970L,12777711870L,3042312350L,636763050L,115775100L,18009460L,2349060L,249900L,20825L,1275L,51L,1L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L},
      {1L,52L,1326L,22100L,270725L,2598960L,20358520L,133784560L,752538150L,3679075400L,15820024220L,60403728840L,206379406870L,635013559600L,1768966344600L,4481381406320L,10363194502115L,21945588357420L,42671977361650L,76360380541900L,125994627894135L,191991813933920L,270533919634160L,352870329957600L,426384982032100L,477551179875952L,495918532948104L,477551179875952L,426384982032100L,352870329957600L,270533919634160L,191991813933920L,125994627894135L,76360380541900L,42671977361650L,21945588357420L,10363194502115L,4481381406320L,1768966344600L,635013559600L,206379406870L,60403728840L,15820024220L,3679075400L,752538150L,133784560L,20358520L,2598960L,270725L,22100L,1326L,52L,1L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L},
      {1L,53L,1378L,23426L,292825L,2869685L,22957480L,154143080L,886322710L,4431613550L,19499099620L,76223753060L,266783135710L,841392966470L,2403979904200L,6250347750920L,14844575908435L,32308782859535L,64617565719070L,119032357903550L,202355008436035L,317986441828055L,462525733568080L,623404249591760L,779255311989700L,903936161908052L,973469712824056L,973469712824056L,903936161908052L,779255311989700L,623404249591760L,462525733568080L,317986441828055L,202355008436035L,119032357903550L,64617565719070L,32308782859535L,14844575908435L,6250347750920L,2403979904200L,841392966470L,266783135710L,76223753060L,19499099620L,4431613550L,886322710L,154143080L,22957480L,2869685L,292825L,23426L,1378L,53L,1L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L},
      {1L,54L,1431L,24804L,316251L,3162510L,25827165L,177100560L,1040465790L,5317936260L,23930713170L,95722852680L,343006888770L,1108176102180L,3245372870670L,8654327655120L,21094923659355L,47153358767970L,96926348578605L,183649923622620L,321387366339585L,520341450264090L,780512175396135L,1085929983159840L,1402659561581460L,1683191473897752L,1877405874732108L,1946939425648112L,1877405874732108L,1683191473897752L,1402659561581460L,1085929983159840L,780512175396135L,520341450264090L,321387366339585L,183649923622620L,96926348578605L,47153358767970L,21094923659355L,8654327655120L,3245372870670L,1108176102180L,343006888770L,95722852680L,23930713170L,5317936260L,1040465790L,177100560L,25827165L,3162510L,316251L,24804L,1431L,54L,1L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L},
      {1L,55L,1485L,26235L,341055L,3478761L,28989675L,202927725L,1217566350L,6358402050L,29248649430L,119653565850L,438729741450L,1451182990950L,4353548972850L,11899700525790L,29749251314475L,68248282427325L,144079707346575L,280576272201225L,505037289962205L,841728816603675L,1300853625660225L,1866442158555975L,2488589544741300L,3085851035479212L,3560597348629860L,3824345300380220L,3824345300380220L,3560597348629860L,3085851035479212L,2488589544741300L,1866442158555975L,1300853625660225L,841728816603675L,505037289962205L,280576272201225L,144079707346575L,68248282427325L,29749251314475L,11899700525790L,4353548972850L,1451182990950L,438729741450L,119653565850L,29248649430L,6358402050L,1217566350L,202927725L,28989675L,3478761L,341055L,26235L,1485L,55L,1L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L},
      {1L,56L,1540L,27720L,367290L,3819816L,32468436L,231917400L,1420494075L,7575968400L,35607051480L,148902215280L,558383307300L,1889912732400L,5804731963800L,16253249498640L,41648951840265L,97997533741800L,212327989773900L,424655979547800L,785613562163430L,1346766106565880L,2142582442263900L,3167295784216200L,4355031703297275L,5574440580220512L,6646448384109072L,7384942649010080L,7648690600760440L,7384942649010080L,6646448384109072L,5574440580220512L,4355031703297275L,3167295784216200L,2142582442263900L,1346766106565880L,785613562163430L,424655979547800L,212327989773900L,97997533741800L,41648951840265L,16253249498640L,5804731963800L,1889912732400L,558383307300L,148902215280L,35607051480L,7575968400L,1420494075L,231917400L,32468436L,3819816L,367290L,27720L,1540L,56L,1L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L},
      {1L,57L,1596L,29260L,395010L,4187106L,36288252L,264385836L,1652411475L,8996462475L,43183019880L,184509266760L,707285522580L,2448296039700L,7694644696200L,22057981462440L,57902201338905L,139646485582065L,310325523515700L,636983969321700L,1210269541711230L,2132379668729310L,3489348548829780L,5309878226480100L,7522327487513475L,9929472283517787L,12220888964329584L,14031391033119152L,15033633249770520L,15033633249770520L,14031391033119152L,12220888964329584L,9929472283517787L,7522327487513475L,5309878226480100L,3489348548829780L,2132379668729310L,1210269541711230L,636983969321700L,310325523515700L,139646485582065L,57902201338905L,22057981462440L,7694644696200L,2448296039700L,707285522580L,184509266760L,43183019880L,8996462475L,1652411475L,264385836L,36288252L,4187106L,395010L,29260L,1596L,57L,1L,0L,0L,0L,0L,0L,0L,0L,0L,0L},
      {1L,58L,1653L,30856L,424270L,4582116L,40475358L,300674088L,1916797311L,10648873950L,52179482355L,227692286640L,891794789340L,3155581562280L,10142940735900L,29752626158640L,79960182801345L,197548686920970L,449972009097765L,947309492837400L,1847253511032930L,3342649210440540L,5621728217559090L,8799226775309880L,12832205713993575L,17451799771031262L,22150361247847371L,26252279997448736L,29065024282889672L,30067266499541040L,29065024282889672L,26252279997448736L,22150361247847371L,17451799771031262L,12832205713993575L,8799226775309880L,5621728217559090L,3342649210440540L,1847253511032930L,947309492837400L,449972009097765L,197548686920970L,79960182801345L,29752626158640L,10142940735900L,3155581562280L,891794789340L,227692286640L,52179482355L,10648873950L,1916797311L,300674088L,40475358L,4582116L,424270L,30856L,1653L,58L,1L,0L,0L,0L,0L,0L,0L,0L,0L},
      {1L,59L,1711L,32509L,455126L,5006386L,45057474L,341149446L,2217471399L,12565671261L,62828356305L,279871768995L,1119487075980L,4047376351620L,13298522298180L,39895566894540L,109712808959985L,277508869722315L,647520696018735L,1397281501935165L,2794563003870330L,5189902721473470L,8964377427999630L,14420954992868970L,21631432489303455L,30284005485024837L,39602161018878633L,48402641245296107L,55317304280338408L,59132290782430712L,59132290782430712L,55317304280338408L,48402641245296107L,39602161018878633L,30284005485024837L,21631432489303455L,14420954992868970L,8964377427999630L,5189902721473470L,2794563003870330L,1397281501935165L,647520696018735L,277508869722315L,109712808959985L,39895566894540L,13298522298180L,4047376351620L,1119487075980L,279871768995L,62828356305L,12565671261L,2217471399L,341149446L,45057474L,5006386L,455126L,32509L,1711L,59L,1L,0L,0L,0L,0L,0L,0L,0L},
      {1L,60L,1770L,34220L,487635L,5461512L,50063860L,386206920L,2558620845L,14783142660L,75394027566L,342700125300L,1399358844975L,5166863427600L,17345898649800L,53194089192720L,149608375854525L,387221678682300L,925029565741050L,2044802197953900L,4191844505805495L,7984465725343800L,14154280149473100L,23385332420868600L,36052387482172425L,51915437974328292L,69886166503903470L,88004802264174740L,103719945525634515L,114449595062769120L,118264581564861424L,114449595062769120L,103719945525634515L,88004802264174740L,69886166503903470L,51915437974328292L,36052387482172425L,23385332420868600L,14154280149473100L,7984465725343800L,4191844505805495L,2044802197953900L,925029565741050L,387221678682300L,149608375854525L,53194089192720L,17345898649800L,5166863427600L,1399358844975L,342700125300L,75394027566L,14783142660L,2558620845L,386206920L,50063860L,5461512L,487635L,34220L,1770L,60L,1L,0L,0L,0L,0L,0L,0L},
      {1L,61L,1830L,35990L,521855L,5949147L,55525372L,436270780L,2944827765L,17341763505L,90177170226L,418094152866L,1742058970275L,6566222272575L,22512762077400L,70539987842520L,202802465047245L,536830054536825L,1312251244423350L,2969831763694950L,6236646703759395L,12176310231149295L,22138745874816900L,37539612570341700L,59437719903041025L,87967825456500717L,121801604478231762L,157890968768078210L,191724747789809255L,218169540588403635L,232714176627630544L,232714176627630544L,218169540588403635L,191724747789809255L,157890968768078210L,121801604478231762L,87967825456500717L,59437719903041025L,37539612570341700L,22138745874816900L,12176310231149295L,6236646703759395L,2969831763694950L,1312251244423350L,536830054536825L,202802465047245L,70539987842520L,22512762077400L,6566222272575L,1742058970275L,418094152866L,90177170226L,17341763505L,2944827765L,436270780L,55525372L,5949147L,521855L,35990L,1830L,61L,1L,0L,0L,0L,0L,0L},
      {1L,62L,1891L,37820L,557845L,6471002L,61474519L,491796152L,3381098545L,20286591270L,107518933731L,508271323092L,2160153123141L,8308281242850L,29078984349975L,93052749919920L,273342452889765L,739632519584070L,1849081298960175L,4282083008118300L,9206478467454345L,18412956934908690L,34315056105966195L,59678358445158600L,96977332473382725L,147405545359541742L,209769429934732479L,279692573246309972L,349615716557887465L,409894288378212890L,450883717216034179L,465428353255261088L,450883717216034179L,409894288378212890L,349615716557887465L,279692573246309972L,209769429934732479L,147405545359541742L,96977332473382725L,59678358445158600L,34315056105966195L,18412956934908690L,9206478467454345L,4282083008118300L,1849081298960175L,739632519584070L,273342452889765L,93052749919920L,29078984349975L,8308281242850L,2160153123141L,508271323092L,107518933731L,20286591270L,3381098545L,491796152L,61474519L,6471002L,557845L,37820L,1891L,62L,1L,0L,0L,0L,0L},
      {1L,63L,1953L,39711L,595665L,7028847L,67945521L,553270671L,3872894697L,23667689815L,127805525001L,615790256823L,2668424446233L,10468434365991L,37387265592825L,122131734269895L,366395202809685L,1012974972473835L,2588713818544245L,6131164307078475L,13488561475572645L,27619435402363035L,52728013040874885L,93993414551124795L,156655690918541325L,244382877832924467L,357174975294274221L,489462003181042451L,629308289804197437L,759510004936100355L,860778005594247069L,916312070471295267L,916312070471295267L,860778005594247069L,759510004936100355L,629308289804197437L,489462003181042451L,357174975294274221L,244382877832924467L,156655690918541325L,93993414551124795L,52728013040874885L,27619435402363035L,13488561475572645L,6131164307078475L,2588713818544245L,1012974972473835L,366395202809685L,122131734269895L,37387265592825L,10468434365991L,2668424446233L,615790256823L,127805525001L,23667689815L,3872894697L,553270671L,67945521L,7028847L,595665L,39711L,1953L,63L,1L,0L,0L,0L},
      {1L,64L,2016L,41664L,635376L,7624512L,74974368L,621216192L,4426165368L,27540584512L,151473214816L,743595781824L,3284214703056L,13136858812224L,47855699958816L,159518999862720L,488526937079580L,1379370175283520L,3601688791018080L,8719878125622720L,19619725782651120L,41107996877935680L,80347448443237920L,146721427591999680L,250649105469666120L,401038568751465792L,601557853127198688L,846636978475316672L,1118770292985239888L,1388818294740297792L,1620288010530347424L,1777090076065542336L,1832624140942590534L,1777090076065542336L,1620288010530347424L,1388818294740297792L,1118770292985239888L,846636978475316672L,601557853127198688L,401038568751465792L,250649105469666120L,146721427591999680L,80347448443237920L,41107996877935680L,19619725782651120L,8719878125622720L,3601688791018080L,1379370175283520L,488526937079580L,159518999862720L,47855699958816L,13136858812224L,3284214703056L,743595781824L,151473214816L,27540584512L,4426165368L,621216192L,74974368L,7624512L,635376L,41664L,2016L,64L,1L,0L,0L},
      {1L,65L,2080L,43680L,677040L,8259888L,82598880L,696190560L,5047381560L,31966749880L,179013799328L,895068996640L,4027810484880L,16421073515280L,60992558771040L,207374699821536L,648045936942300L,1867897112363100L,4981058966301600L,12321566916640800L,28339603908273840L,60727722660586800L,121455445321173600L,227068876035237600L,397370533061665800L,651687674221131912L,1002596421878664480L,1448194831602515360L,1965407271460556560L,2507588587725537680L,3009106305270645216L,3397378086595889760L,3609714217008132870L,3609714217008132870L,3397378086595889760L,3009106305270645216L,2507588587725537680L,1965407271460556560L,1448194831602515360L,1002596421878664480L,651687674221131912L,397370533061665800L,227068876035237600L,121455445321173600L,60727722660586800L,28339603908273840L,12321566916640800L,4981058966301600L,1867897112363100L,648045936942300L,207374699821536L,60992558771040L,16421073515280L,4027810484880L,895068996640L,179013799328L,31966749880L,5047381560L,696190560L,82598880L,8259888L,677040L,43680L,2080L,65L,1L,0L},
      {1L,66L,2145L,45760L,720720L,8936928L,90858768L,778789440L,5743572120L,37014131440L,210980549208L,1074082795968L,4922879481520L,20448884000160L,77413632286320L,268367258592576L,855420636763836L,2515943049305400L,6848956078664700L,17302625882942400L,40661170824914640L,89067326568860640L,182183167981760400L,348524321356411200L,624439409096903400L,1049058207282797712L,1654284096099796392L,2450791253481179840L,3413602103063071920L,4472995859186094240L,5516694892996182896L,6406484391866534976L,7007092303604022630L,7219428434016265740L,7007092303604022630L,6406484391866534976L,5516694892996182896L,4472995859186094240L,3413602103063071920L,2450791253481179840L,1654284096099796392L,1049058207282797712L,624439409096903400L,348524321356411200L,182183167981760400L,89067326568860640L,40661170824914640L,17302625882942400L,6848956078664700L,2515943049305400L,855420636763836L,268367258592576L,77413632286320L,20448884000160L,4922879481520L,1074082795968L,210980549208L,37014131440L,5743572120L,778789440L,90858768L,8936928L,720720L,45760L,2145L,66L,1L}
   };
   
    
    /** computes the binomial coefficients.*/
    /*
    private static long[][] binomes(int n) {
       long[][] comb = new long[n][n];
       for (int i = 0; i < comb.length; i++) {
          for (int j = 0; j <= i; j++) {
             if (i == 0 || i == j || j == 0) {
                comb[i][j] = 1;
             } else {
                if (j == 1 || j == i - 1) {
                   comb[i][j] = i;
                } else {
                   comb[i][j] = comb[ i - 1 ] [ j - 1 ] + comb[ i - 1 ] [ j ];
                }
             }
          }
       }
       return comb;
    }
    */
    
   /** Returns the beta function value 
    *  <i>B(z,w)</i> = &int;<sub>0</sub><sup>1</sup> <i>t</i><sup>z-1</sup> 
    * (1-<i>t</i>)<sup>w-1</sup> d<i>t</i>.
    *  We have <i>B(z,w) = B(w,z) = &Gamma;(z) &Gamma;(w) / &Gamma;(z+w).</i>
    *  @param z first argument
    *  @param w second argument
    *  @return value of the beta function B(z,w)
    *  @see #gamma(double)
    */
   public static double beta(double z, double w) {
      if (w < 1e-8) {
         return 1e30;
      } else {
         return exp(lnGamma(z) + lnGamma(w) - lnGamma(z+w));
      }
   }
   
   /** The incomplete beta function for 0 &lt;= x &lt;= 1. For a&gt;0, b&gt;0 it is defined by
    *  <pre style="font-size:90%">
    *
    *                      1
    *       I_x (a,b) = --------  int_0^x  t^{a-1} (1-t)^{b-1} dt.
    *                    B(a,b)
    *
    *  </pre>
    *  It can be well approximated by the continued fraction
    *  <pre style="font-size:90%">
    *
    *                    x^a (1-x)^b   {  1                }
    *       I_x (a,b) = -------------  { ----------------- }
    *                      a B(a,b)    {        d_1        }
    *                                  {  1 + ------------ }
    *                                  {          d_2      }
    *                                  {      1 + -------- }
    *                                  {              d_3  }
    *                                  {          1 + ---- }
    *                                  {               ... }
    *  </pre>
    *  with the coefficients
    *  <pre style="font-size:90%">
    *
    *                     (a+m)(a+b+m)                  m(b-mm)
    *       d_{2m+1} = - -------------- x,  d_{2m} = --------------  x.
    *                    (a+2m)(a+2m-1)              (a+2m-1)(a+2m)
    *
    *  </pre>
    *  The approximation converges rapidly for
    *  <pre style="font-size:90%">
    *
    *            a+1
    *       x &gt; -----.
    *           a+b+1
    *
    *  </pre>
    *  If this condition is not satisfied, then just 1-x does, and we can apply
    *  the symmetry relation
    *  <pre style="font-size:90%">
    *
    *       I_x (a,b) = 1 - I_{1-x} (b,a).
    *
    *  </pre>
    *  @param a first parameter of the beta function, a &gt; 0
    *  @param b second parameter of the beta function, b &gt; 0
    *  @param x index
    *  @return the incomplete beta function value
    *  @see #beta(double,double)
    */
   public static double incBeta(double a, double b, double x) {
      final double accuracy = 1e-8;
      double d__1;
      int m;
      double d2m, d2m1, xlim, apl2m, //a, b, x, 
           cfnew, fnorm, a1, b1, a2, b2, cf, rm;
      boolean reflec;

      xlim = (a + 1.) / (a + b + 1.);
      if (x < xlim) {
         reflec = false;
      } else {
         reflec = true;
         double tmp = a;
         a = b;
         b = tmp;
         x = 1. - x;
      }
      if (x < 1e-8) {
         /* function known at end of range */
         cf = 0.;
      } else {
         /* continued fraction */
         a1 = 1.;
         b1 = 1.;
         a2 = 1.;
         b2 = 1. - (a + b) * x / (a + 1.);
         fnorm = 1. / b2;
         cf = a2 * fnorm;
         for (m = 1; m <= 100; ++m) {
            rm = m;
            apl2m = a + rm * 2.;
            d2m = rm * (b - rm) * x / ((apl2m - 1.) * apl2m);
            d2m1 = -(a + rm) * (a + b + rm) * x / (apl2m * (apl2m + 1));
            a1 = (a2 + d2m * a1) * fnorm;
            b1 = (b2 + d2m * b1) * fnorm;
            a2 = a1 + d2m1 * a2 * fnorm;
            b2 = b1 + d2m1 * b2 * fnorm;
            if (b2 != 0.f) {
               /* renormalize and test for convergence */
               fnorm = 1. / b2;
               cfnew = a2 * fnorm;
               if ((d__1 = cf - cfnew) < accuracy && abs(d__1) / cf < accuracy) {
                  break;
               }
               cf = cfnew;
            }
         }
         d__1 = 1. - x;
         cf = cf * Math.pow(x, a) * Math.pow(d__1, b) / (a * beta(a, b));
      }
      if (reflec) {
         return 1. - cf;
      } else {
         return cf;
      }
   }

   /** 
    *  The Euler Gamma function 
    *  <!--
    *     Gamma(x) = int_0^infinity t^(x-1) e^{-t} dt.
    *  -->
    *  <p style="text-align:center">
    *    &#x0393;(<i>x</i>) = &int;<sub>0</sub><sup>&#x221E;</sup>
    *      <i>t</i><sup><i>x</i>-1</sup> e<sup>-<i>t</i></sup> d<i>t</i>.
    *  </p>
    *  @param x the argument
    *  @return the value &Gamma;(<i>x</i>)
    *  @see #beta(double, double)
    */
   public static double gamma(double x) {
      double[] c = { 76.18009173,-86.50532033,24.01409822,-1.231739516,.00120858003,-5.36382e-6 };

      double anum, g, s, xh, xx, xgh;
      int i;
      boolean reflec;

      if (x >= 1.) {
         reflec = false;
         xx = x - 1.;
      } else {
         reflec = false;
         xx = 1. - x;
      }
      xh = xx + .5;
      xgh = xx + 5.5;
      s = 1.;
      anum = xx;
      for (i = 0; i < c.length; ++i) {
         anum += 1.;
         s += c[i] / anum;
      }
      s *= 2.506628275;
      g = Math.pow(xgh, xh) * s / exp(xgh);
      if (reflec) {
         return xx * PI / (g * sin(xx * PI));
      } else {
         return g;
      }
   }

   /** Logarithm of the Euler Gamma function. It is computed according to the
    *  <a href="http://en.wikipedia.org/wiki/Lanczos_approximation">Lanczos approximation</a>.
    *  See S. Brandt: <i>Datenanalyse.</i> Spektrum Akademischer Verlag, Heidelberg Berlin, 
    *  &sect;D.1
    *  @param x the argument
    *  @return the logarithm ln(Gamma(x)) of the Gamma function
    *  @see #gamma(double)
    */
   public static double lnGamma(double x) {
      double[] c = {
           76.18009172947146,   -86.50532032941677,  24.01409824083091,
          -1.231739572450155, .1208650973866179e-2, -.5395239384953e-5
      };

      int i;
      double anum, g, s, xh, xx, xgh;
      boolean reflec;

      if (x >= 1.) {
         reflec = false;
         xx = x - 1.;
      } else {
         reflec = true;
         xx = 1. - x;
      }
      xh = xx + .5;
      xgh = xx + 5.5;
      s = 1.;
      anum = xx;
      for (i = 0; i < c.length; ++i) {
         anum += 1.;
         s += c[i] / anum;
      }
      s *= 2.5066282746310005;
      g = xh * log(xgh) + log(s) - xgh;
      if (reflec) {
         return log(xx * PI) - g - log(sin(xx * PI));
      } else {
         return g;
      }
   }

   /** incomplete Gammma function.
    *  @param a the argument, a &gt; 0
    *  @param x the argument
    *  @return the incGamma(a,x)
    *  @see #gamma(double)
    */
   public static double incGamma(double a, double x) {
      final double accuracy = 1e-6;
      double d__1;
      int i, iMax = 100;
      double help, anum, f, s, cfnew=0, a0, b0, a1, b1, fnorm, cf, aloggm,
             a2j, b2j, a2j1, b2j1;

      aloggm = lnGamma(a);
      if (x <= a + 1.) {
         /* series development */
         f = 1. / a;
         s = f;
         anum = a;
         i = 1;
         do {
            anum += 1.;
            f = x * f / anum;
            s += f;
        } while (f > accuracy && i <= iMax);
        if (x < accuracy) {
            return 0.;
        } else {
            help = a * log(x) - x - aloggm;
            if (abs(help) >= 500.) {
                return 0.;
            } else {
                return s * exp(help);
            }
        }
      } else {
         /* continued fraction */
         a0 = 0.;
         b0 = 1.;
         a1 = 1.;
         b1 = x;
         cf = 1.;
         fnorm = 1.;
         i = 1;
         do {
            a2j  = i - a;
            a2j1 = i;
            b2j = 1.;
            b2j1 = x;
            a0 = (b2j * a1 + a2j * a0) * fnorm;
            b0 = (b2j * b1 + a2j * b0) * fnorm;
            a1 = b2j1 * a0 + a2j1 * a1 * fnorm;
            b1 = b2j1 * b0 + a2j1 * b1 * fnorm;
            if (b1 != 0.) {
               /* renormalize and test for convergence */
               fnorm = 1. / b1;
               cfnew = a1 * fnorm;
               cf = cfnew;
            }
            i++;
         } while (((d__1 = cf - cfnew) > accuracy || abs(d__1) / cf > accuracy) && i <= iMax);
         help = a * log(x) - x - aloggm;
         if (abs(help) >= 500.) {
            return 1.;
         } else {
            return 1. - exp(help) * cfnew;
         }
      }
   }
   

   /** Returns the exact binomial coefficient (<i>n</i> choose <i>k</i>)
    *  as an integer.
    * @param n an integer
    * @param k an integer
    * @return (<i>n</i> over <i>k</i>)
    */
   public static BigInteger exactBinomial(int n, int k) {
      if (k < 0 || (n >= 0 && k > n)) return BigInteger.ZERO;
      if (k == 0 || k == n) return BigInteger.ONE;
      if (n >= 0 && n < binomial.length && k < binomial.length) return BigInteger.valueOf(binomial[n][k]);
      if (n < 0 && k - n - 1 < binomial.length && k < binomial.length) {
         return (k%2 == 0) ? BigInteger.valueOf(binomial[k-n-1][k]) : BigInteger.valueOf(-binomial[k-n-1][k]);
      }
      
      boolean nNegative;
      
      if (nNegative = (n < 0)) {
         n = k - n - 1;
         if (n < k) return BigInteger.ZERO; 
      }
      
      BigInteger[][] comb = new BigInteger[n+1][k+1];
      for (int i = 0; i < comb.length; i++) {
         for (int j = 0; j < comb[i].length; j++) {
            if (i == 0 || i == j || j == 0) {
               comb[i][j] = BigInteger.ONE;
            } else {
               if (j == 1 || j == i - 1) {
                  comb[i][j] = BigInteger.valueOf(i);
               } else {
                  comb[i][j] = comb[i - 1][j - 1].add(comb[i - 1] [j]);
               }
            }
         }
      }
      if (nNegative && k%2 == 0) comb[n][k] = comb[n][k].negate();  
      return comb[n][k];
   }

   /** Returns the binomial coefficient (<i>n</i> choose <i>k</i>)
    *  as a floating point number.
    *  @param n an integer
    *  @param k an integer
    *  @return (<i>n</i> over <i>k</i>)
    */
   public static double binomial(long n, long k) {
      if (k < 0 || k > n) return 0.;
      return floor(.5 + exp(lnFactorial(n) - lnFactorial(k) - lnFactorial(n-k)));
   }
   
   /** Returns ln (<i>n</i>!).
    *  @param n an integer
    *  @return ln (<i>n</i>!)
    */
   public static double lnFactorial(long n) {
      if (n < 0) return Double.NEGATIVE_INFINITY;
      else if (n <= 1) return 0.;
      else return lnGamma(n + 1.0);
   }
   
   /** Returns the exact value of <i>n</i>!.
    *  Argument values <i>n</i> %gt;&gt; 10000 lead to unreasonable running times.
    *  @param n the value to be computed
    *  @return the value of <i>n</i>!
    *  @throws IllegalArgumentException if <i>n</i> &lt; 0
    */
   public static BigInteger factorial(int n) {
      if (n < 0) throw new IllegalArgumentException("("+n+")! is not defined!");
      
      BigInteger m = BigInteger.ONE;
      
      for (long k = 2; k <= n; k++) {
         m = m.multiply(BigInteger.valueOf(k));
      }
      return m;
   }
   
   /** Returns the value of <i>n</i> mod <i>m</i>, even for negative values.
    *  Here the usual periodic definition is used, i.e.,
    *  <p style="text-align:center">
    *    <i>n</i> mod <i>m</i> = <i>n</i> - &#x23A3;<i>n</i>/<i>m</i>&#x23A6;
    *    &nbsp; for <i>m</i> &#x2260; 0,
    *    &nbsp; and <i>n</i> mod 0 = <i>n</i>.
    *  </p>
    *  For instance,
    *  5 mod 3 = 2, but -5 mod 3 = 1, 5 mod (-3) = -1, and -5 mod (-3) = -2.
    *  See R.L. Graham, D.E. Knuth, O. Patashnik: <i>Concrete Mathematics.</i>
    *  2nd Edition. Addison-Wesley, Upper Saddle River, NJ 1994, &sect;3.4 (p.82)
    *  @param n the value to be raised to the power
    *  @param m the modulus
    *  @return the value <i>n</i> mod <i>m</i>
    */
   public static long mod(long n, long m) {
      if (m == 0) return n;
      byte mPositive = 1;
      if (m < 0) {mPositive = -1; m = -m; n = -n;}
      return (n >= 0) ? n%m * mPositive : (m + n%m)%m * mPositive;
   }

   /** Returns the value of <i>n</i> mod <i>m</i>, even for negative values.
    *  Here the usual periodic definition is used, i.e., 
    *  5 mod 3 = 2, but -5 mod 3 = 1, 5 mod (-3) = -1, and -5 mod (-3) = -2.
    *  See R.L. Graham, D.E. Knuth, O. Patashnik: <i>Concrete Mathematics.</i>
    *  2nd Edition. Addison-Wesley, Upper Saddle River, NJ 1994, &sect;3.4 (p.82)
    *  @param n the value to be computed
    *  @param m the modulus
    *  @return the value <i>n</i> mod <i>m</i>
    */
   public static double mod(double n, double m) {
      if (m == 0) return n;
      byte mPositive = 1;
      if (m < 0) {mPositive = -1; m = -m; n = -n;}
      return (n >= 0) ? n%m * mPositive : (m + n%m)%m * mPositive;
   }

   /** Returns the value of <i>x<sup>e</sup></i>.
    *  @param x the value to be raised to the power
    *  @param e the exponent
    *  @return the value of <i>x<sup>e</sup></i>
    *  @throws IllegalArgumentException if e &lt; 0
    */
   public static long pow(long x, long e) {
      if (e < 0) {
         throw new IllegalArgumentException("This version of pow expects a nonnegative exponent");
      }
      long y = 1;
      
      while (e > 0) {
         if ((e & 1L) == 1) { //  <=>  if (e % 2 == 1) {
            y *= x;
         }
         x *= x;
         e = e >> 1; // <=> e /= 2;
      }
      return y;
      
      /* Alternative (recursion):
      public static long pow(int x, int e) {
         if (e<0) {
            throws new IllegalArgumentException();
         } else if (e==0) {
            return 1;
         } else if (e==1) {
            return x;
         } else if (e==2) {
            return x * x;
         } else if (e % 2 == 0) {
            return pow(x * x, e/2);
         } else {
            return x * pow(x, e-1);
         }
      }
      // */
      
   }

   /** Returns the value of <i>x<sup>e</sup></i>.
    *  @param x the value to be raised to the power
    *  @param e the exponent
    *  @return the value of <i>x<sup>e</sup></i>
    */
   public static double pow(double x, long e) {
      if (e < 0) return pow(x, e);
      
      double y = 1.;
      
      while (e > 0) {
         if ((e & 1L) == 1) { //  <=>  if (e % 2 == 1) {
            y *= x;
         }
         x *= x;
         e = e >> 1; // <=> e /= 2;
      }
      return y;
   }

   /** Returns the value of 2<sup><i>n</i></sup>.
    *  @param n the exponent
    *  @return the value of 2<sup><i>n</i></sup>
    */
   public static long pow2(int n) {
      return 1L << n;
   } 

   /** Returns the value of <i>x<sup>e</sup></i> mod <i>n</i>.
    *  @param x the value to be raised to the power
    *  @param e the exponent
    *  @param m the modulus
    *  @return the value of <i>x<sup>e</sup></i> mod <i>n</i>
    *  @throws ArithmeticException if <i>e</i> &lt; 0 and gcd(<i>x</i>, <i>n</i>) &gt; 1
    */
   public static int modPow(long x, long e, int m) {
      long n = (long) m;
      //if (n == 0) throw new ArithmeticException("Division by 0");
      if (e < 0) {
         // find the multiplicative inverse of x mod n by the extended Euclid algorithm:
         long[] euclid = euclid(x,n);
         if (euclid[0] == 1) { // gcd(x,n) == 1
            x = euclid[1];
            e = -e;
         } else {
            throw new ArithmeticException(
               "Negative exponent "+e+" is not possible, gcd("+x+ ", "+n+") > 1"
            );
         }
      }
      
      long y = 1;
      if (n > 0) {
         x = (int) mod(x, n);
         while (e > 0) {
            if ((e & 1L) == 1) { //  <=>  if (e % 2 == 1) {
               y = (y * x) % n;
            }
            x = (x * x) % n;
            e = e >> 1; // <=> e /= 2;
         }
         return (int) y;
      } else {
         x = (int) mod(x, n);
         while (e > 0) {
            if ((e & 1L) == 1) { //  <=>  if (e % 2 == 1) {
               y = mod(y * x, n);
            }
            x = mod(x * x, n);
            e = e >> 1; // <=> e /= 2;
         }
         return (int) y;         
      }
   }

   /** Returns the value of <i>x<sup>e</sup></i> mod <i>n</i>.
    *  @param x the value to be raised to the power
    *  @param e the exponent
    *  @param n the modulus
    *  @return the value of <i>x<sup>e</sup></i> mod <i>n</i>
    *  @throws ArithmeticException if <i>e</i> &lt; 0 and gcd(<i>x</i>, <i>n</i>) &gt; 1
    */
   public static long modPow(long x, long e, long n) {
      //if (n == 0) throw new ArithmeticException("Division by 0");
      if (e < 0) {
         // find the multiplicative inverse of x mod n by the extended Euclid algorithm:
         long[] euclid = euclid(x,n);
         if(euclid[0] == 1) { // gcd(x,n) == 1
            x = euclid[1];
            e = -e;
         } else {
            throw new ArithmeticException(
                  "Negative exponent "+e+" is not possible ("+x+ " and "+n+" are not relatively prime)"
            );
         }
      }
      long y = 1;
      if (n > 0) {
         x = mod(x, n);         
         while (e > 0) {
            if ((e & 1L) == 1) { //  <=>  if (e % 2 == 1) {
               y = (y * x) % n;
            }
            x = (x * x) % n;
            e = e >> 1; // <=> e /= 2;
         }
         return y;
      } else {
         while (e > 0) {
            if ((e & 1L) == 1) { //  <=>  if (e % 2 == 1) {
               y = mod(y * x, n);
            }
            x = mod(x * x, n);
            e = e >> 1; // <=> e /= 2;
         }
         return y;         
      }
   }
   
   /** Returns the value of (<i>x<sup>e</sup></i>) mod <i>n</i>.
    *  @param x the value to be raised to the power
    *  @param e the exponent
    *  @param n the modulus
    *  @return the value of <i>x<sup>e</sup></i> mod <i>n</i>
    */
   public static double modPow(double x, long e, double n) {
      return mod(pow(x, e), n);
   }
   
   /** Returns sqrt(a^2 + b^2) without under/overflow.
    *  This method can be conveniently used to compute iteratively the norm
    *  <code>norm</code> of a vector 
    *  <b><i>x</i></b> = (<i>x</i><sub>0</sub>, ..., <i>x</i><sub><i>n</i>-1</sub>) by
    *  <pre>
    *    double norm = 0;
    *    for (int i = 0; i &lt; x.length; i++) {
    *       norm = Numbers.hypotenuse(norm, x[i]);
    *    }
    *  </pre>
    *  @param a the first triangle leg
    *  @param b the first triangle leg
    *  @return sqrt(a^2 + b^2)
    */
   public static double hypotenuse(double a, double b) {
      double r;
      if (Math.abs(a) > Math.abs(b)) {
         r = b/a;
         r = Math.abs(a) * Math.sqrt(1 + r*r);
      } else if (b != 0) {
         r = a/b;
         r = Math.abs(b) * Math.sqrt(1 + r*r);
      } else {
         r = 0.0;
      }
      return r;
   }

   /** Returns the <i>n</i>th root of <i>z</i>, with an accuracy of 1e-12 <i>z</i>.
    *  The root is understood as the principal root <i>r</i> with the unique real
    *  number with the same sign as <i>z</i> such that <i>r<sup>n</sup> = z</i>.
    *  If <i>n</i> = 0, the values 0, 1, or {@link Double#POSITIVE_INFINITY} is returned
    *  depending on whether |<i>z</i>| &lt; 0, |<i>z</i>| = 1, or <i>z</i> &gt; 1;
    *  if <i>n</i> = 0 and <i>z</i> &lt; -1, then the value is not defined and an exception is thrown.
    *  If <i>n</i> &lt; 0, then root(-<i>n</i>, <i>z</i>) is returned.
    *  @param n the radical
    *  @param z the radicand
    *  @return the principal <i>n</i>th root <i>r</i> of <i>z</i> such that 
    *  <i>r<sup>n</sup> = z</i>
    *  @throws IllegalArgumentException if (a) <i>n</i> = 0 and <i>z</i> &lt; -1, 
    *     or (b) <i>z</i> &lt; 0 and <i>n</i> is even
    */
   public static double root(int n, double z) {
      byte sign = 1;
      double w = Math.pow(2, floor(log(z))/(n * log(2)));
      double accuracy = z * 1e-12;

      if (n == 0) {
         if (abs(z) < 1) return 0;
         else if (z > 1) return Double.POSITIVE_INFINITY;
         else throw new IllegalArgumentException("0-th root of a number z < -1 is not defined");
      }
      if (n < 0) return 1 / root(-n,z);
      
      if (z < 0) {
         if (n % 2 == 0) {
            throw new IllegalArgumentException("Even root of a negative number is a real number");
            //System.err.println("Complex number exception: root of a negative number!");
            //return .0; // better: throw new ComplexNumberException();
         }
         sign = -1;
         z = -z;
      }
      
      while (abs(pow(w,n) - z) > accuracy) {
         // w = (n-1) w/n + z/(n w^(n-1)):
         w = (n-1)*w/n + z/(n * pow(w,n-1));
      }
      return sign * w;
   }

   /** Returns the value of <i>x</i><sup>2</sup>.
    *  @param x the value to be squared
    *  @return the square of the input <i>x</i>, i.e., <i>x</i><sup>2</sup>
    */
   public static long sqr(long x) {
      return x*x;
   }
   
   /** Returns the greatest common divisor of the integers <i>m</i> and <i>n</i>.
    *  @param m the first integer
    *  @param n the second integer
    *  @return the greatest commom divisor of <i>m</i> and <i>n</i>
    */
   public static long gcd(long m, long n) {
      if (n == 0) {
         return m;
      } else {
         return gcd(n, m % n);
      }
   }
   
   /** Returns an array of three integers x[0], x[1], x[2] as given by the extended
    *  Euclidian algorithm for <i>positive</i> integers <i>m</i> and <i>n</i>. 
    *  The three integers satisfy the equations
    *  <p style="text-align:center">
    *    <i>x</i>[0] = gcd(<i>m</i>, <i>n</i>) 
    *                = <i>x</i>[1] <i>m</i> + <i>x</i>[2] <i>n</i>.
    *  </p>
    *  This methods implements a recursive version of the extended Euclidian algorithm.
    *  @param m the first integer, must be positive
    *  @param n the second integer, must be positive
    *  @return an array of three integers <i>x</i>[0], <i>x</i>[1], <i>x</i>[2] 
    *    such that <i>x</i>[0] = gcd(<i>m</i>, <i>n</i>) 
    *    = <i>x</i>[1] <i>m</i> + <i>x</i>[2] <i>n</i>
    *  @see #gcd(long,long)
    *  @see BigNumbers#euclid(java.math.BigInteger,java.math.BigInteger)
    */
   public static long[] euclid(long m, long n) {
      if (n == 0) {
         return new long[] {m, 1, 0};
         //long[] x = {m, 1, 0};
         //return x;
      } else {
         long[] x = euclid(n, m % n);
         // swap:
         x[1] ^= x[2];
         x[2] ^= x[1];
         x[1] ^= x[2];
         x[2] -= (m/n) * x[1];
         // likewise:
         //long tmp = x[1];
         //x[1] = x[2];
         //x[2] = tmp - (m/n) * x[1];
         return x;
      }
   }
      
   /** Returns the least common multiple of <i>m</i> and <i>n</i>.
    *  It is computed by lcm(<i>m</i>, <i>n</i>) = <i>mn</i> / gcd(<i>m</i>, <i>n</i>).
    *  @param m the first integer 
    *  @param n the second integer
    *  @return the least common multiple of <i>m</i> and <i>n</i>
    *  @see #gcd(long,long)
    */
   public static long lcm(long m, long n) {
      return (m * n) / gcd(m, n);
   }

   /** Tests deterministically whether the given integer is prime.
    *  This algorithm is a naive trial division primality test, appropriate only 
    *  for comparably small integers.
    *  @param n the integer to test
    *  @return true if and only if n i prime.
    */
   public static boolean isPrime(long n) {
      if (n == 2) return true;
      if (n < 0 || n % 2 == 0) {
         return false;
      }
      long d = 3;
      long s = (long) ceil(sqrt(n));
      while (d <= s) {
         if (n % d == 0) return false;
         d += 2;
      }
      return true;
   }

   /** Returns the array {<i>d,x,y</i>} such that the linear Diophantine equation 
    *  <p style="text-align:center;">
    *    <i>ax</i> + <i>by</i> = <i>c</i>
    *  </p>
    *  is solved and <i>d</i> = gcd(<i>a</i>,<i>b</i>).
    *  If the equation is not solvable, then {0,0,0} is returned.
    *  Note that the equation is solvable if and only if gcd(a,b) divides c.
    *  Moreover, from a given solution {<i>x</i><sub>0</sub>, <i>y</i><sub>0</sub>}
    *  a general solution can be computed by
    *  <p style="text-align:center;">
    *    <i>x</i> = <i>x</i><sub>0</sub> + <i>bt/d</i>,
    *    &nbsp; &nbsp;
    *    <i>y</i> = <i>y</i><sub>0</sub> - <i>at/d</i>
    *  </p>
    *  for <i>t</i> &isin; &#x2124;.
    *  Cf. R. Schulze.Pillot: <i>Elementare Algebra und Zahlentheorie.</i>
    *  Springer, Berlin Heidelberg 2007, Satz 3.12.
    *  @param a first coefficient of the linear Diophantine equation
    *  @param b second coefficient of the linear Diophantine equation
    *  @param c third coefficient of the linear Diophantine equation
    *  @return the array {d,x,y} such that the linear Diophantine equation 
    *  <i>ax</i> + <i>by</i> = <i>c</i> is solved and <i>d</i> = gcd(<i>a</i>,<i>b</i>),
    *  or {0,0,0} if the equation is not solbvable
    */
   public static long[] solveLinearDiophantine(long a, long b, long c) {
      long[] x = euclid(a, b);
      if (x[0] < 0) x[0] = -x[0]; // = gcd(a, b)
      if (c % x[0] != 0) return new long[] {0,0,0}; // Diophantine equation is not solvable!
      long t = gcd(x[1], x[2]); if (t < 0) t = -t;
      x[1] /= t; x[2] /= t; // cancel
      x[1] *= c / x[0]; x[2] *= c / x[0];
      return x;
   }
   
   /** Returns true if <i>n</i> is a strong probable prime to base <i>a</i>,
    *  and false if <i>n</i> is not prime.
    *  This algorithm is the core of the Miller-Rabin primality test,
    *  cf. R. Crandall &amp; C. Pomerance:
    *  <i>Prime Numbers. A Computational Perspective.</i> 2<sup>nd</sup> edition.
    *  Springer, New York 2005, &sec;3.5.
    *  The number <i>n</i> must be an odd number &gt; 3, and 1 &lt; <i>a</i> &lt; n-1.
    *  @param n the number to be tested on strong probable primality
    *  @param a the base of the strong probable primality test
    *  @return true if <i>n</i> is a strong probable prime to base <i>a</i>,
    *  and false if <i>n</i> is not prime
    *  @throws IllegalArgumentException if <i>n</i> &le; 3, or <i>a</i> &le; 1, 
    *  or <i>a</i> &ge; <i>n</i> - 1
    *  @see BigNumbers#isStrongProbablePrime(BigInteger,BigInteger)
    */
   public static boolean isStrongProbablePrime(int n, int a) {
      if (n <= 3 || a <= 1 || a >= n - 1) {
         throw new IllegalArgumentException("n="+n+", a="+a);
      }
      
      // Determine s and t such that n-1 = t*2^s:
      int  s = 0;
      long t = n-1;
      while (t % 2 == 0) {
         t /= 2;
         s++;
      }
      
      // Test the odd part t of n-1:
      long b = Numbers.modPow(a, t, n);
      if (b == 1 || b == n-1) {
         return true;
      }
      
      // Test the power of 2 in n-1:
      for (int j = 1; j < s; j++) {
         b = (b*b) % n;
         if (b == n-1) {
            return true;
         }
      }
      return false;
   }

   /**
    *  Determines the least prime factor of a number, using naive trial division, appropriate
    *  only for comparably small integers.
    *  @param n an integer
    *  @return the least prime factor of n
    */
   public static int leastPrimeFactor(int n) {
      if (n % 2 == 0) return 2;
      int d = 3;
      double s = sqrt(n);
      while (d < s) {
         if (n % d == 0) return d;
         d += 2;
      }
      return n;
   }

   /**
    *  Determines the largest prime factor of a number, using naive trial division, appropriate
    *  only for comparatively small integers.
    *  @param n an integer
    *  @return the largest prime factor of n
    */
   public static int largestPrimeFactor(int n) {
      if (n % 2 == 0) return n/2;
      int d = (int) sqrt(n);
      while (d > 1) {
         if (n % d == 0 && isPrime(d)) return d;
         d--;
      }
      return n;
   }

   /** Returns the order ord(<i>m,n</i>) of <i>m</i> modulo <i>n</i>. 
    *  More precisely, we have
    *  <!--
    *
    *     ord(m,n) = min_i { i > 0 : m^i = 1 mod n },
    *
    *  -->
    *  <p style="text-align:center">
    *
    *     ord(<i>m,n</i>) = min<sub><i>i</i></sub> { <i>i</i> &gt; 0 : <i>m<sup>i</sup></i> = 1 mod <i>n</i> },
    *
    *  </p>
    *  The order is found by Floyd's cycle finding algorithm.
    *  @param m the first integer 
    *  @param n the second integer
    *  @return the order of <i>m</i> mod <i>n</i>
    */
   public static long ord(long m, long n) {
      long i, x, y;
      m = m % n;
      if (gcd(m,n) != 1) {
         i = 0;
      } else {
         i = 1;
         x = m;
         y = (m*x) % n;
         while (x != y) {
            // i++; x = (m*x) mod n; y = (m*y)^2 mod n:
            i++;
            x = (m*x) % n;
            y = (m*m*y) % n; 
         }
      }
      return i;
   }
   
   /** Tests whether there exist integers <i>m</i> and <i>k</i> such that
    *  <i>n = m<sup>k</sup></i>.
    *  @param n the number to be checked
    *  @return true if and only if there exist integers <i>m</i> and <i>k</i> such that
    *  <i>n = m<sup>k</sup></i>
    */
   public static boolean isPower(long n) {
      double temp;
      double greatexp = log(n) / log(2);
      /*
      if (TWO.pow(greatexp).compareTo(n) == 0) { // 2^g == n?
         return true;
      } else {
         greatexp--;
      }
      */
      int k = 2;
      boolean flag = false;
      
      while (k <= greatexp && !flag) {
         temp = pow(round(Numbers.root(k, n)), k);
         flag = (n == round(temp));
         k++;
      }
      return flag;
   }
   
   /** Returns an array containing coefficients of the continued fraction of 
    *  the number <i>x</i>, with at most <code>limit</code> coefficients. 
    *  Note that by the finite precision of <i>x</i> the higher continuous fraction 
    *  coefficients get more and more imprecise. For instance, for the
    *  Euler number the coefficients are correct up to the limit 20.
    *  @param x the number to be expanded as a continuous fraction
    *  @param limit the maximum number of continuous fraction coefficients to be computed
    *  @return an array of length <code>limit</code> containing the continuous fraction coefficients
    */
   public static long[] continuedFraction(double x, int limit) {
      double accuracy = 1e-7;
      if (x == .0) return new long[1];
      if (x <  .0) x = -x;
      long[] a = new long[limit];
      if (limit <= 0) return a;
      int i = 0;
      double xi;

      if (x >= 1) {
         xi = 1/x - (long) (1/x);
      } else {
         xi = x;
         a[0] = 0;
         i++;
      }

      while (xi > accuracy && i < limit) {
         a[i] = (long) (1/xi);
         xi = 1/xi - a[i];
         i++;
      }

      long[] result = new long[i];
      //for(int j=0; j < result.length; j++) {
      //   result[j] = a[j];
      //}
      System.arraycopy(a, 0, result, 0, result.length);
      return result;
   }
   
   /** Returns the best rational approximation of a real number <i>x</i>,
     * that is, the integers <i>p, q</i> such that <i>x</i> &#x2248; <i>p/q</i>.
     * The algorithm computes the continued fraction coefficients corresponding to
     * <i>x</i>, where the number of coefficients is bounded by
     * <code>limit</code>. Usually, the value of <code>limit</code> should be about 20.
     * @param x the number to be approximated
     * @param limit the maximum number of continued fraction coefficients being considered
     * @return a two-element array <code>y</code> where <code>y[0]</code> = <i>p</i> and
     * <code>y[1]</code> = <i>q</i> such that <i>x</i> &#x2248; <i>p/q</i>
     * @see #continuedFraction(double,int)
     */
   public static long[] bestRationalApproximation(double x, int limit) {
      long[] cf = continuedFraction(x,limit);
      // q_{k-2} = q1, q_{k-1} = q2, q_{k} = q3:
      long q1 = 1, q2 = 0, q3 = 1; // <- k=0
      // p_{k-2} = p1, p_{k-1} = p2, p_{k} = p3:
      long p1 = 0, p2 = 1, p3 = 0; // <- k=0
      for (long a : cf) {
         // p_{k} = a_{k} p_{k-1} + p_{k-2}:
         p3 = a * p2 + p1;
         p1 = p2;
         p2 = p3;
         // q_{k} = a_{k} q_{k-1} + q_{k-2}:
         q3 = a * q2 + q1;
         q1 = q2;
         q2 = q3;
      }
      if (x < 0) p3 = -p3;
      return new long[]{p3,q3};
   }

   
   /** Returns the Bernoulli number <i>B<sub>n</sub></i> of the nonnegative integer 
    *  <i>n</i>. <i>B<sub>n</sub></i> is recursively defined as
   <table style="margin:auto;" summary="">
     <tr>
       <td> 
         <i>B<sub>n</sub></i>
       </td><td align="center"> 
         &nbsp; = &nbsp; -
       </td><td>
         <table summary="" border="0">
           <tr><td align="center">1</td></tr> 
           <tr><td style="height:1px;"><hr></td></tr> 
           <tr><td align="center"><i>n</i>+1</td></tr> 
         </table>
       </td><td>
         <table summary="" border="0"> 
           <tr><td align="center" class="small"><i>n</i>-1</td></tr> 
           <tr><td align="center" style="font-size:xx-large;">&#931;</td></tr> 
           <tr><td align="center" class="small"><i>j</i> = 0</td></tr> 
         </table> 
       </td><td align="center" style="font-size:xx-large;">(
       </td><td>
         <table summary="" border="0">
           <tr><td align="center"><i>n</i>+1</td></tr> 
           <tr><td align="center"><i>j</i></td></tr> 
         </table>
       </td><td align="center" style="font-size:xx-large;">)
       </td><td> 
         <i>B<sub>j</sub></i>
       </td>
     </tr>
   </table>
     * and <i>B</i><sub>0</sub> = 1. Note that in case of repeatedly required
     * Bernoulli numbers the method {@link #bernoulliNumbers(int)} may be
     * used more efficiently, giving the whole list of Bernoulli numbers
     * up to <i>B<sub>n</sub></i>.
     * @param n a nonnegative integer
     * @return a rational number representing <i>B<sub>n</sub></i>
     * @throws IllegalArgumentException if n&lt;0
     * @see #bernoulliNumbers(int)
     */
   public static Rational bernoulli(int n) {
      if (n < 0) throw new IllegalArgumentException("Bernoulli number for "+n+" is not defined.");
      if (n == 0) return new Rational(1,1);
      return bernoulliNumbers(n)[n];
   }
   
   /** Returns an array of <i>n</i>+1 rational numbers with entry number <i>j</i>
    *  representing the Bernoulli number <i>B<sub>j</sub></i>, <i>j</i> = 0, 1, ..., <i>n</i>.
    *  Since the Bernoulli numbers are defined recursively, this method allows
    *  efficient implementations for algorithms which repeatedly use
    *  Bernoulli numbers.
    * @param n a nonnegative integer
    * @return a rational number representing <i>B<sub>n</sub></i>
    * @throws IllegalArgumentException if n&lt;0
    * @see #bernoulli(int)
    */
   public static Rational[] bernoulliNumbers(int n) {
      if (n < 0) throw new IllegalArgumentException("Bernoulli number for "+n+" is not defined.");
      Rational[] numbers = new Rational[n+1];
      numbers[0] = new Rational(1,1);
      for(int m=1; m <= n; m++) {
         numbers[m] = new Rational(0,1);
         for(int j=0; j < m; j++) {
            numbers[m] = numbers[m].subtract(
               numbers[j].multiply(exactBinomial(m+1,j))
            );
         }
         numbers[m] = numbers[m].divide(m+1);
      }
      return numbers;
   }
   
   /** Returns an array of the numbers of partitions up to the number <i>n</i>.
     * A partition of a positive integer <i>n</i> is a set of tuples
     * consisting of positive summands yielding a total of exactly <i>n</i>. 
     * For instance, there are three partitions of <i>n</i> = 3, namely 
     * {(1,1,1), (1,2), (3)} since 1 + 1 + 1 = 1 + 2 = 3.
     * <p>
     * For details see
     * R.L. Graham, D.E. Knuth, O. Patashnik: <i>Concrete Mathematics.</i>
     * 2nd Edition. Addison-Wesley, Upper Saddle River, NJ 1994, &sect;7.1 (p. 330)
     * </p>
     * @param n a positive integer
     * @return an array <code>p</code> of the numbers of partitions where 
     * <code>p[i]</code> is the number of partitions of <code>i</code> &le; <i>n</i>.
     * @see #partitions(int)
     */
   public static java.math.BigInteger[] numberOfPartitions(int n) {
      if (n < 0) n = -n;

      java.math.BigInteger[] p = new java.math.BigInteger[n+1];
      // p_0 = 1:
      p[0] = java.math.BigInteger.ONE;
      for (int k = 1; k < p.length; k++) {
         p[k] = java.math.BigInteger.ZERO;
      }
      for (int m = 1; m <= n; m++) {
         for (int k=1; (3*k - 1)*k/2 <= m; k++) {
            if (k % 2 == 0) {
               p[m] = p[m].subtract(p[m - (3*k - 1)*k/2]);
               if ((3*k + 1)*k/2 <= m) {
                  p[m] = p[m].subtract(p[m - (3*k + 1)*k/2]);
               }
            } else {
               p[m] = p[m].add(p[m - (3*k - 1)*k/2]);
               if ((3*k + 1)*k/2 <= m) {
                  p[m] = p[m].add(p[m - (3*k + 1)*k/2]);
               }
            }
         }
      }
      return p;
   }

   /**
    * Returns a list of all partitions of a small integer <i>n</i>.
    * A partition of a positive integer is a set of positive integers
    * {<i>n</i><sub>1</sub>, ..., <i>n<sub>k</sub></i>} whose sum equals <i>n</i>,
    * i.e., <i>n</i><sub>1</sub> +  ... + <i>n<sub>k</sub></i> = <i>n</i>.
    * For instance, there are three partitions of <i>n</i> = 3, namely 
    * {{1,1,1}, {1,2}, {3}} since 1 + 1 + 1 = 1 + 2 = 3.
    * <p>
    * The running time behavior of this algorithm is very bad, the required 
    * time complexity is estimated as <i>O</i>((<i>n</i>!)<sup>2</sup>).
    * The computation of the partitions for a small number <i>n</i> &lt; 50
    * is done in less than 30 seconds, but for instance <i>n</i> = 60 requires
    * about 4 minutes on a 2 GHz dual core processor system.
    * If you are interested only in the number of partitions, you may consider
    * {@link #numberOfPartitions(int)}.
    * </p>
    * <p>
    * For details see
    * R.L. Graham, D.E. Knuth, O. Patashnik: <i>Concrete Mathematics.</i>
    * 2nd Edition. Addison-Wesley, Upper Saddle River, NJ 1994, &sect;7.1 (p. 330)
    * </p>
    * @param n a positive integer
    * @return list of all partitions of the specified integer <i>n</i>.
    * @see #numberOfPartitions(int)
    */
   public static ArrayList<LinkedList<Integer>> partitions(int n) {
      ArrayList<LinkedList<Integer>> partitions = new ArrayList<>();
      if (n == 1) {
         LinkedList<Integer> part = new LinkedList<>();
         part.add(1);
         partitions.add(part);
         return partitions;
      } else {
         int stage, i;
         int pos = 0; // position for next stage
         LinkedList<Integer> part;
         ArrayList<LinkedList<Integer>> p_prev = partitions(n-1);
         partitions = new ArrayList<>();
         for (LinkedList<Integer> p_ : p_prev) {
            part = new LinkedList<>();
            for (int x : p_) {
               part.add(x);
            }
            partitions.add(part);
         }
         
         // Insert 1 at first position:
         for (i = 0; i < partitions.size(); i++) {
            part = partitions.get(i);
            if (part.size() > 1 && part.get(1) <= 1) {
               pos++;
            }
            part.addFirst(1);
         }

         for (stage = 2; stage <= n/2; stage++) {
            for(i = pos; i < p_prev.size(); i++) {
               part = new LinkedList<>();
               for (int x : p_prev.get(i)) {
                  part.addLast(x);
               }
               if (stage + sum(part) - part.getFirst() == n) {
                  if (part.size() > 1 && stage <= part.get(1)) {
                     part.set(0, stage);
                     partitions.add(part);
                  }
               }
            }
            part = p_prev.get(pos);
            while (part.size() > 1 && part.get(1) <= stage) {
               pos++;  // for the next stage ...
               part = p_prev.get(pos);
            }
         }
         part = new LinkedList<>();
         part.add(n);
         partitions.add(part);
         return partitions;
      }
   }
   
   /** Returns the sum of the integers of the specified list.
    *  @param list a list of integers
    *  @return the sum of the integers contained in the list
    */
   public static int sum(java.util.Collection<Integer> list) {
      int sum = 0;
      for (int x : list) {
         sum += x;
      }
      return sum;
   }
   
   /** Returns the hexadecimal digit of <i>&pi;</i> at the given position,
    *  according to the Bailey-Borwein-Plouffe algorithm.
    *  The digit is computed in <i>n</i>+1 iterations each of which requiring
    *  <i>O</i>(log <i>n</i>) elementary arithmetic operations, yielding a
    *  time complexity of <i>O</i>(<i>n</i> log <i>n</i>) for the entire algorithm.
    *  @param position the position of the searched hexadecimal digit
    *  @return the hexadecimal digit of <i>&pi;</i> at the given position
    */
   public static char bbp(long position) {
      if (position <  0) return '0';
      if (position == 0) return '3';
      
      long n = position - 1;
      long digit;
      double sum = 0;
      for (long k = 0; k <= n; k++) {
        sum +=   4 * modPow(16, n-k, 8*k + 1) / (8*k + 1.) 
               - 2 * modPow(16, n-k, 8*k + 4) / (8*k + 4.) 
               -     modPow(16, n-k, 8*k + 5) / (8*k + 5.) 
               -     modPow(16, n-k, 8*k + 6) / (8*k + 6.);
      }
      // digit = (16*sum - floor(16 * sum)) mod 16:
      digit = (long) (16 * ((sum < 0) ? (sum - (long) sum + 1) : (sum - (long) sum)));
      
      if (digit < 10) {
         return (char) (digit + 48);
      } else if (digit == 10) {
         return 'A';
      } else if (digit == 11) {
         return 'B';
      } else if (digit == 12) {
         return 'C';
      } else if (digit == 13) {
         return 'D';
      } else if (digit == 14) {
         return 'E';
      } else if (digit == 15) {
         return 'F';
      } else {
         System.err.println("Error in BBP algorithm!!! digit = " + digit);
         return '?';
      }
   }

   /** Returns <i>n</i> as a binary string.
    * @param n the decimal value to be represented in binary form
    * @return string representing the binary representation of n
    */
   public static String decToBin(long n) {
     int base = 2;
     boolean negative = false;
     String symbols = "";
     long q = n, r;
     
     if (n == 0) {
       symbols = "0";
     } else {
        if (n < 0) {
           q = -q;
           negative = true;
        }
     
        while (q > 0) {
           r = q % base;
           symbols = r + symbols;
           q /= base;
        }
     }
     
     if (negative) symbols = "-" + symbols;
     return symbols;
   }
   
  /** Returns <i>n</i> as a binary string of the specified minimum length.
   * @param n the decimal value to be represented in binary form
   *  @param minimumLength the minimum length of the returned binary string
   * @return string representing the binary representation of n
   */
   public static String decToBin(long n, int minimumLength) {
      boolean negative = false;
      if (n < 0) {
         n = -n;
         negative = true;
      }
      String out = decToBin(n);
      // pad with zeros:
      for (int i = out.length(); i < minimumLength; i++) {
         out = "0" + out;
      }
      if (negative) out = "-" + out;
      return out;
   }

   /** Returns <i>n</i> as a binary string in a 1-byte form.
    *  @param n the decimal number to be represented in a 1 byte binary form.
    *  @return string representing the binary representation of n
    */
   public static String decToBinByte(long n) {
      boolean negative = false;

      if (n < 0) {
         negative = true;
         n = -n;
      }

      String result = decToBin(n);

      while (result.length() % 4 != 0) {
         result = "0" + result;
      }
      if (negative) result = "-" + result;
      return result;
   }
   
   /** Returns a binary string as an integer.
    *  @param bin the binary string to be represented in decimal form
    *  @return the long integer representing the binary string
    *  @throws NumberFormatException if the string is not binary
    */
   public static long binToDec(String bin) {
      return Long.parseLong(bin, 2);
      /*
      int base = 2;
      boolean negative = false;
      String symbol;
      int a_i = 0;
      long n = 0L;
      
      if (bin.substring(0,1).equals("-")) {
        negative = true;
        bin = bin.substring(1);
      }
      if (bin.substring(bin.length()-1, bin.length()).equals("-")) {
        negative = true;
        bin = bin.substring(0, bin.length() - 1);
      }
      
      for (int i = 0; i < bin.length(); i++) {
        symbol = bin.substring(i, i+1);
        a_i = Integer.parseInt(symbol);
        if (a_i > 1) {
           throw new NumberFormatException ("No binary number");
        }
        n += a_i * pow(base,bin.length() - i - 1);
      }
      
      if (negative)  n = -n;
      return n;
      */
   }
   
   /** Returns <i>z</i> as a binary string with at most 70 digits right of
    *  the binary point.
    *  @param z the decimal value to be represented in binary form.
    *  @return the binary representation of <i>z</i>
    */
   public static String decToBin(double z) {
      return decToBin(z, 60);
   }

   /** Returns <i>z</i> as a binary string with at most <code>limit</code>
    *  positions right of the binary point.
    *  @param z the decimal value to be represented in binary form.
    *  @param limit the maximum position after the binary point.
    *  @return the binary representation of <i>z</i>
    */
   public static String decToBin(double z, int limit) {
      int base = 2;
      boolean negative = false;
      String symbols;
      
      if (z == 0) {
         symbols = "0";
      } else {
         if (z < 0) {
            z = -z;
            negative = true;
         }
         
         symbols = decToBin((long) z) + ".";
         
         z -= (long) z;
         z *= base;
         int r;
         int counter = 0;
         while (z > 0 && counter <= limit) {
            r = (int) z;
            symbols += r;
            z -= r;
            z *= base;
            counter++;
         }
      }
      return negative? "-" + symbols : symbols;
   }
   
   /** Returns a binary string as a decimal floating-point number.
    *  @param bin the binary string to be represented in decimal form.
    *  @return the double number representing the binary string
    *  @throws NumberFormatException if the string is not binary
    */
   public static double binToDouble(String bin) {
      int base = 2;
      boolean negative = false;
      String symbol;
      double a_i, x;
      int point; // position of hexadecimal point
      
      if (bin.substring(0,1).equals("-")) {
        negative = true;
        bin = bin.substring(1);
      }
      if (bin.substring(bin.length()-1, bin.length()).equals("-")) {
        negative = true;
        bin = bin.substring(0,bin.length() - 1);
      }
      
      point = bin.indexOf('.');

      if (point == -1) {  // the string represents an integer!
         return negative? -binToDec(bin) : binToDec(bin);
      }
      
      if (point == 0) {
         bin = "0" + bin;
         point = 1;
      }
      
      x = binToDec(bin.substring(0,point));
      
      //System.out.println("x="+x);
            
      bin = bin.substring(point+1, bin.length());
      
      for (int i = 0; i < bin.length(); i++) {
        symbol = bin.substring(i, i+1);
        a_i = Double.parseDouble(symbol); //Integer.parseInt(symbol);
        if (a_i > 1) {
           throw new NumberFormatException ("No binary number \""+bin+"\"");
        }
        x += a_i / pow(base, i+1);
      }      
      return negative? -x : x;
   }
   
   /** Returns a binary string as a hexadecimal string.
    *  @param bin the binary string to be represented in hexadecimal form
    *  @return the hexadecimal string representing the binary string
    *  @throws NumberFormatException if the string is not binary
    */
   public static String binToHex(String bin) {
      String hex = "";
      bin = bin.replace(',','.');
      String[] b = bin.split("\\.");
      for (int k = 0; k < b.length; k++) {
         // pad the binary string with 0's to represent full tetrads:
         if (b[k].length() % 4 > 0) {
            int length = b[k].length();
            for (int i = 0; i < 4 - length % 4; i++) {
               if (k==0) { // integral part
                  b[k] = "0" + b[k];
               } else { // fractional part
                  b[k] = b[k] + "0";
               }
            }
         }
         String substring;
         if (k == 1) {
            hex += ".";
         }
         for (int i = 0; i < b[k].length(); i += 4) {
            substring = b[k].substring(i, i+4);
            if (substring.equals("0000")) {
               hex += "0";
            } else if (substring.equals("0001")) {
               hex += "1";
            } else if (substring.equals("0010")) {
               hex += "2";
            } else if (substring.equals("0011")) {
               hex += "3";
            } else if (substring.equals("0100")) {
               hex += "4";
            } else if (substring.equals("0101")) {
               hex += "5";
            } else if (substring.equals("0110")) {
               hex += "6";
            } else if (substring.equals("0111")) {
               hex += "7";
            } else if (substring.equals("1000")) {
               hex += "8";
            } else if (substring.equals("1001")) {
               hex += "9";
            } else if (substring.equals("1010")) {
               hex += "A";
            } else if (substring.equals("1011")) {
               hex += "B";
            } else if (substring.equals("1100")) {
               hex += "C";
            } else if (substring.equals("1101")) {
               hex += "D";
            } else if (substring.equals("1110")) {
               hex += "E";
            } else if (substring.equals("1111")) {
               hex += "F";
            } else {
               throw new NumberFormatException("No binary string "+bin);
            }
         }
      }
      return hex;
   }

  /** Returns <i>n</i> as a ternary string.
   * @param n the decimal value to be represented in ternary form
   * @return string representing the ternary representation of n
   */
   public static String decToTern(long n) {
      int base = 3;
      boolean negative = false;
      String symbols = "";
      long q = n, r;
      
      if (n == 0) {
         symbols = "0";
      } else {
         if (n < 0) {
            q = -q;
            negative = true;
         }
         
         while (q > 0) {
            r = q % base;
            symbols = r + symbols;
            q /= base;
         }
      }
      if (negative) symbols = "-" + symbols;
      return symbols;
   }
   
  /** Returns <i>n</i> as a ternary string of the specified minimum length.
   *  @param n the decimal value to be represented in ternary form
   *  @param minimumLength the minimum length of the returned ternary string
   *  @return string representing the ternary representation of n
   */
   public static String decToTern(long n, int minimumLength) {
      boolean negative = false;
      if (n < 0) {
         n = -n;
         negative = true;
      }
      String out = decToTern(n);
      // pad with zeros:
      for (int i = out.length(); i < minimumLength; i++) {
         out = "0" + out;
      }
      if (negative) out = "-" + out;
      return out;
   }

   /** Returns a ternary string as an integer.
    *  @param tern the ternary string to be represented in decimal form
    *  @return the long integer representing the ternary string
    *  @throws NumberFormatException if the string is not ternary
    */
   public static long ternToDec(String tern) {
      return Long.parseLong(tern, 3);
      /*
      int base = 3;
      boolean negative = false;
      String symbol;
      int a_i = 0;
      long n = 0L;
      
      if (tern.substring(0,1).equals("-")) {
         negative = true;
         tern = tern.substring(1);
      }
      if (tern.substring(tern.length()-1, tern.length()).equals("-")) {
         negative = true;
         tern = tern.substring(0, tern.length() - 1);
      }
      
      for (int i = 0; i < tern.length(); i++) {
         symbol = tern.substring(i, i+1);
         a_i = Integer.parseInt(symbol);
         if (a_i > 2) {
            throw new NumberFormatException ("No ternary number");
         }
         n += a_i * pow(base,tern.length() - i - 1);
      }
      
      if (negative)  n = -n;
      return n;
      */
   }
   
   /** Returns <i>z</i> as a ternary string with at most 40 digits right of
    *  the ternary point.
    *  @param z the decimal value to be represented in ternary form.
    *  @return the ternary representation of <i>z</i>
    */
   public static String decToTern(double z) {
      return decToTern(z, 40);
   }

   /** Returns <i>z</i> as a ternary string with at most <code>limit</code>
    *  positions right of the ternary point.
    *  @param z the decimal value to be represented in ternary form.
    *  @param limit the maximum position after the ternary point.
    *  @return the ternary representation of <i>z</i>
    */
   public static String decToTern(double z, int limit) {
      int base = 3;
      boolean negative = false;
      String symbols;
      
      if (z == 0) {
         symbols = "0";
      } else {
         if (z < 0) {
            z = -z;
            negative = true;
         }
         
         symbols = decToTern((long) z) + ".";
         
         z -= (long) z;
         z *= base;
         int r;
         int counter = 0;
         while (z > 0 && counter <= limit) {
            r = (int) z;
            symbols += r;
            z -= r;
            z *= base;
            counter++;
         }
      }
      return negative? "-" + symbols : symbols;
   }
   
   /** Returns a ternary string as a decimal floating-point number.
    *  @param tern the ternary string to be represented in decimal form.
    *  @return the double number representing the ternary string
    *  @throws NumberFormatException if the string is not ternary
    */
   public static double ternToDouble(String tern) {
      int base = 3;
      boolean negative = false;
      String symbol;
      int a_i;
      double x;
      int point; // position of hexadecimal point
      
      if (tern.substring(0,1).equals("-")) {
        negative = true;
        tern = tern.substring(1);
      }
      if (tern.substring(tern.length()-1, tern.length()).equals("-")) {
        negative = true;
        tern = tern.substring(0,tern.length() - 1);
      }
      
      point = tern.indexOf('.');

      if (point == -1) {  // the string represents an integer!
         return negative? -ternToDec(tern) : ternToDec(tern);
      }
      
      if (point == 0) {
         tern  = "0" + tern;
         point = 1;
      }
      
      x = ternToDec(tern.substring(0,point));
      
      //System.out.println("x="+x);
            
      tern = tern.substring(point+1, tern.length());
      
      for (int i = 0; i < tern.length(); i++) {
        symbol = tern.substring(i, i+1);
        a_i = Integer.parseInt(symbol);
        if (a_i > 2) {
           throw new NumberFormatException ("No ternary number \""+tern+"\"");
        }
        x += a_i / pow(base, i+1);
      }
      
      return negative? -x : x;
   }
      
   /** Returns the ternary complement of the specified number in ternary
    *  representation. Here every digit '0' is changed to '2' and vice versa.
    *  @param tern number in ternary representation
    *  @return ternary complement of the specified number tern
    */
   public static String ternaryComplement(String tern) {
      int m_n, carry, i;
      String sum; 
      String c = "";
      char s;
      
      for (i = 0; i < tern.length(); i++) {
         //System.out.println("### tern="+tern+" -> c=" + c + ", one="+one);
         s = tern.charAt(i);
         if (s == '0') {
            s = '2';
         } else if (s == '2') {
            s = '0';
         }         
         c += s;
      }
      
      // add 1 to lowest digit:
      sum = "";
      m_n = Integer.parseInt(""+c.charAt(c.length() - 1)) + 1;
      if (m_n < 3) {
         sum   = m_n + sum;
         carry = 0;
      } else {
         sum   = m_n - 3 + sum;
         carry = 1;
      }
      
      for(i = c.length() - 2; i >= 0; i--) {
         if (c.charAt(i) == '.') {
            sum = "." + sum;
            continue;
         }
         m_n = Integer.parseInt(c.substring(i,i+1)) + carry;
         //System.out.print("+++ " + c.charAt(i)+"+"+carry+"="+m_n);
         if (m_n < 3) {
            sum   = m_n + sum;
            carry = 0;
         } else {
            sum   = m_n - 3 + sum;
            carry = 1;
         }
         //System.out.println(" -> "+sum);
      }
      // insert sign digit:
      c = "2" + sum;
      //System.out.println("### tern="+tern+" -> c=" + c);
      return c;
    }
   
   /** Returns the sum of <i>m</i> and <i>n</i> in the ternary system.
    *  It is defined by [<i>n</i>/3] except for the case <i>n</i> % 2 where
    *  it gives [<i>n</i>/3] + 1.
    *  @param m number in ternary representation
    *  @param n number in ternary representation
    *  @return the sum <i>m</i> + <i>n</i> in the ternary representation
    */
   public static String add3(String m, String n) {
      int start, end, carry, m_n, pointM, pointN, point, i;
      String sum;
      boolean negative = false;
      
      if (m.substring(0,1).equals("-")) {
        negative = true;
        m = ternaryComplement(m.substring(1));
      } else if (m.substring(m.length()-1, m.length()).equals("-")) {
        negative = true;
        m = ternaryComplement(m.substring(0,m.length() - 1));
      }
      
      if (n.substring(0,1).equals("-")) {
        negative = true;
        n = ternaryComplement(n.substring(1));
      } else if (n.substring(n.length()-1, n.length()).equals("-")) {
        negative = true;
        n = ternaryComplement(n.substring(0,n.length() - 1));
      }
      
      pointM = m.indexOf('.');
      pointN = n.indexOf('.');
      
      if (pointM == -1) {
         pointM = m.length();
         m = m + ".";
      }
      if (pointN == -1) {
         pointN = n.length();
         n = n + ".";
      }
      
      String intM  = m.substring(0,pointM);
      String intN  = n.substring(0,pointN);
      String fracM = m.substring(pointM + 1);
      String fracN = n.substring(pointN + 1);
      
      // pad with zeros:
      if (fracM.length() > fracN.length()) {
         start = fracM.length();
         for (int j = fracN.length(); j < start; j++) {
            fracN += "0";
         }
      } else {
         start = fracN.length();
         for (int j = fracM.length(); j < start; j++) {
            fracM += "0";
         }
      }
      if (intM.length() > intN.length()) {
         end = intM.length();
         for (int j = intN.length(); j < end; j++) {
            intN = "0" + intN;
         }
      } else {
         end = intN.length();
         for (int j = intM.length(); j < end; j++) {
            intM = "0" + intM;
         }
      }
      //System.out.println("### m="+intM+"."+fracM);
      //System.out.println("### n="+intN+"."+fracN);
      
      carry = 0;
      sum   = "";
      for(i = start - 1; i >= 0; i--) {
         m_n = Integer.parseInt(fracM.substring(i,i+1)) 
             + Integer.parseInt(fracN.substring(i,i+1))
             + carry;
         //System.out.print("fff) " + m_i +"+"+n_i+"+"+carry+"="+m_n);
         if (m_n < 3) {
            sum   = m_n + sum;
            carry = 0;
         } else {
            sum   = m_n - 3 + sum;
            carry = 1;
         }
         //System.out.println(" -> "+sum);
      }
      
      if (!sum.equals("")) sum = "." + sum;
      
      for(i = end - 1; i >= 0; i--) {
         m_n = Integer.parseInt(intM.substring(i,i+1)) 
             + Integer.parseInt(intN.substring(i,i+1))
             + carry;
         //System.out.print("iii) " + m_i +"+"+n_i+"+"+carry+"="+m_n);
         if (m_n < 3) {
            sum   = m_n + sum;
            carry = 0;
         } else {
            sum   = m_n - 3 + sum;
            carry = 1;
         }
         //System.out.println(" -> "+sum);
      }
      
      if (negative && sum.charAt(0) == '2') {
         sum = ternaryComplement(sum.substring(1));
         //System.out.println("*** 1) check: negative="+negative+", sum="+sum);
         sum = sum.substring(1);
      } else if (negative && sum.charAt(0) != '2') {
         negative = false;
         //System.out.println("*** 1) check: negative="+negative+", sum="+sum);
      } else if (!negative && carry == 1) {
         sum = "1" + sum;
      }
      //System.out.println("*** 2) check: negative="+negative+", sum="+sum);
      
      //System.out.println("### vorher: sum="+sum);
      // Cut leading and trailing zeros:
      point = sum.indexOf('.');
      if (point == -1) {
         sum = sum.substring(0, sum.length() - 1);
         point = sum.length();
      }
      
      i = 0;
      while (i < point && sum.charAt(i) == '0') {
         i++;
         point--;
      }
      if (i>0) sum = sum.substring(i);
      if (sum.indexOf('.') == 0) sum = "0" + sum;
      
      i = sum.length() - 1;
      while (i > point && sum.charAt(i) == '0') {
         i--;
      }
      if (i < sum.length() - 1) sum = sum.substring(0, i);            

      //System.out.println("### nachher: sum="+sum);

      if (negative) sum = "-" + sum;
      return sum;
   }
   
   // --- balanced ternary system: ---v-----------------------------------------
   /** Symbol in balanced ternary system for -1.*/
   public static final char TBM = 'n';
   /** Symbol in balanced ternary system for 0.*/
   public static final char TB0 = '0';
   /** Symbol in balanced ternary system for +1.*/
   public static final char TBP = 'p';

  /** Returns the integer division <i>n</i>/3 in the balanced ternary system.
   *  It is defined by [<i>n</i>/3] except for the case <i>n</i> % 2 where
   *  it gives [<i>n</i>/3] + 1.
   *  @param n the decimal value to be divised
   *  @return the integer division <i>n</i>/3 in the balanced ternary system
   */
   public static long div3b(long n) {
      boolean negative = false;
      long q;
      
      if (n < 0) {
         negative = true;
         n = -n;
      }
      q = (n % 3 == 2) ? n/3 + 1 : n/3;
      return negative? -q : q;
   }
   
  /** Returns the symbol in the balanced ternary system representing the value 
   *  <i>n</i> mod 3.
   *  @param n the decimal value to be divised
   *  @return the symbol in the balanced ternary system representing the value 
   *  <i>n</i> mod 3. 
   */
   public static char mod3b(long n) {
      if (n < 0) {
         n = (3 + (n % 3)) % 3;
      }
      
      if (n % 3 == 1) {
         return TBP;
      } else if (n % 3 == 0) {
         return TB0;
      } else {
         return TBM;
      }
   }
   
  /** Returns <i>n</i> as a balanced ternary string.
   * @param n the decimal value to be represented in ternary form
   * @return string representing the balanced ternary representation of n
   */
   public static String decToTernB(long n) {
      String symbols = "";
      long q = n;
      char r;
     
      if (n == 0) {
         symbols = "" + TB0;
      } else {
         while (q != 0) {
            r = mod3b(q);
            symbols = r + symbols;
            q = div3b(q);
         }
      }
      return symbols;
   }
   
  /** Returns <i>n</i> as a balanced ternary string of the specified minimum length.
   *  @param n the decimal value to be represented in balanced ternary form
   *  @param minimumLength the minimum length of the returned ternary string
   *  @return string representing the balanced ternary representation of n
   */
   public static String decToTernB(long n, int minimumLength) {
      String out = decToTernB(n);
      // pad with zeros:
      for (int i = out.length(); i < minimumLength; i++) {
         out = "0" + out;
      }
      return out;
   }

   /** Returns a balanced ternary string as an integer.
    *  @param tern the ternary string to be represented in decimal form
    *  @return the long integer representing the ternary string
    *  @throws NumberFormatException if the string is not ternary
    */
   public static long ternBToDec(String tern) {
      char symbol;
      int a_i = 0;
      long n = 0L;
      
      for (int i = 0; i < tern.length(); i++) {
         symbol = tern.charAt(i);
         if (symbol == TBM) {
            a_i = -1;
         } else if (symbol == TB0) {
            a_i = 0;
         } else if (symbol == TBP) {
            a_i = 1;
         } else {
            throw new NumberFormatException ("No ternary number \""+tern+"\"");
         }
         n += a_i * pow(3, tern.length() - i - 1);
     }
     return n;
   }
   
   /** Returns <i>z</i> as a balanced ternary string with at most 
    *  40 digits right of
    *  the ternary point.
    *  @param z the decimal value to be represented in balanced ternary form.
    *  @return the balanced ternary representation of <i>z</i>
    */
   public static String decToTernB(double z) {
      return decToTernB(z, 40);
   }

   /** Returns <i>z</i> as a balanced ternary string with at most <code>limit</code>
    *  positions right of the ternary point.
    *  @param z the decimal value to be represented in balanced ternary form.
    *  @param limit the maximum position after the ternary point.
    *  @return the balanced ternary representation of <i>z</i>
    */
   public static String decToTernB(double z, int limit) {
      return ternToTernB(decToTern(z,limit));
   }
   
   /** Returns a balanced ternary string as a decimal floating-point number.
    *  @param tern the ternary string to be represented in decimal form.
    *  @return the BigDecimal number representing the balanced ternary string
    *  @throws NumberFormatException if the string is not balanced ternary
    */
   public static double ternBToDouble(String tern) {
      boolean negative = false;
      char symbol;
      int a_i = 0;
      double x;
      int point; // position of hexadecimal point
      
      if (tern.substring(0,1).equals("-")) {
        negative = true;
        tern = tern.substring(1);
      }
      if (tern.substring(tern.length()-1, tern.length()).equals("-")) {
        negative = true;
        tern = tern.substring(0,tern.length() - 1);
      }
      
      point = tern.indexOf('.');

      if (point == -1) {  // the string represents an integer!
         return negative? -ternBToDec(tern) : ternBToDec(tern);
      }
      
      if (point == 0) {
         tern  = "0" + tern;
         point = 1;
      }
      
      x = ternToDec(tern.substring(0,point));
      
      //System.out.println("x="+x);
            
      tern = tern.substring(point+1, tern.length());
      
      for (int i = 0; i < tern.length(); i++) {
         symbol = tern.charAt(i);
         if (symbol == TBM) {
            a_i = -1;
         } else if (symbol == TB0) {
            a_i = 0;
         } else if (symbol == TBP) {
            a_i = 1;
         } else {
            throw new NumberFormatException ("No ternary number \""+tern+"\"");
         }
         x += a_i / pow(3, tern.length() - i - 1);
     }
     
     return negative? -x : x;      
   }
   
   /** Returns a ternary string as an balanced ternary string.
    *  @param tern the ternary string to be represented in balanced ternary form
    *  @return the balanced ternary string representing the ternary string
    *  @throws NumberFormatException if the string is not ternary
    */
   public static String ternToTernB(String tern) {
      String tb = "";
      String ones = "";
      int point, i;
      String tmp = "";
      
      // Determine whether tern is negative:
      if (tern.substring(0,1).equals("-")) {
         tern = tern.substring(1);
      }
      if (tern.substring(tern.length()-1, tern.length()).equals("-")) {
         tern = tern.substring(0, tern.length() - 1);
      }
      
      // Cut leading and trailing zeros:
      point = tern.indexOf('.');
      if (point == -1) point = tern.length();
      
      i = 0;
      while (i < point && tern.charAt(i) == '0') {
         i++;
      }
      for (int j = i; j < point; j++) {
         tmp += tern.charAt(j);
      }
      
      i = tern.length() - 1;
      while (i > point && tern.charAt(i) == '0') {
         i--;
      }
      
      if (point != tern.length()) {
         tmp += ".";
      }
      
      for (int j = point + 1; j <= i; j++) {
         tmp += tern.charAt(j);
      }
      
      if (tmp.indexOf('.') == 0) tmp = "0" + tmp;

      tern = tmp;
      
      // Determine string of ones which covers tern:
      point = tern.indexOf('.');
      if (point == -1) {
         for(i = 0; i <= tern.length(); i++) {
            ones += "1";
         }
      } else {
         for(i = 0; i <= point; i++) {
            ones += "1";
         }
         ones += ".";
         for(i = point; i < tern.length() - 1; i++) {
            ones += "1";
         }
      }
      
      // Add ones + tern:
      tern = add3(ones, tern);
      tmp = tern.substring(0);
      
      for (i = 0; i < tmp.length(); i++) {
         if (tmp.charAt(i) == '2') {
            tb += TBP;
         } else if (tmp.charAt(i) == '1') {
            tb += TB0;
         } else if (tmp.charAt(i) == '0') {
            tb += TBM;
         } else {
            tb += '.';
         }
      }
      
      // cut leading zero:
      if (tb.charAt(0) == '0') tb = tb.substring(1);
      
      return tb;
   }
   // --- balanced ternary system  ---^-----------------------------------------
   
   /** Returns <i>n</i> as a hexadecimal string.
    *  @param n the decimal value to be represented in hexadecimal form.
    *  @return string representing the hexadecimal representation of n
    */
   public static String decToHex(long n) {
      int base = 16;
      boolean negative = false;
      String symbols = "";
      long q = n, r;
      
      if (n == 0) {
         symbols = "0";
      } else {
         if (n < 0) {
            q = -q;
            negative = true;
         }     
         
         while (q > 0) {
            r = q % base;
            if (r <= 9) {
               symbols = r + symbols;
            } else if (r == 10) {
               symbols = "A" + symbols;
            } else if (r == 11) {
               symbols = "B" + symbols;
            } else if (r == 12) {
               symbols = "C" + symbols;
            } else if (r == 13) {
               symbols = "D" + symbols;
            } else if (r == 14) {
               symbols = "E" + symbols;
            } else if (r == 15) {
               symbols = "F" + symbols;
            }
            q /= base;
         }
      }
      if (negative)  symbols = "-" + symbols;
      return symbols;
   }

  /** Returns <i>z</i> as a hexadecimal string with at most 20 digits right of
   *  the hexadecimal point.
   *  @param z the decimal value to be represented in hexadecimal form.
   *  @return the hexadecimal representation of <i>z</i>
   */
   public static String decToHex(double z) {
      return decToHex(z, 20);
   }

  /** Returns <i>z</i> as a hexadecimal string with at most <code>limit</code>
   *  positions right of the hexadecimal point.
   *  @param z the decimal value to be represented in hexadecimal form.
   *  @param limit the maximum position after the hexadecimal point.
   *  @return the hexadecimal representation of <i>z</i>
   */
   public static String decToHex(double z, int limit) {
      int base = 16;
      boolean negative = false;
      String symbols;
      
      if (z == 0) {
         symbols = "0";
      } else {
         if (z < 0) {
            z = -z;
            negative = true;
         }
         
         symbols = decToHex((long) z) + ".";         
         z -= (long) z;
         z *= base;
         int r;
         int counter = 0;
         
         while (z > 0 && counter <= limit) {
            r = (int) z;
            if (r <= 9) {
               symbols += r;
            } else if (r == 10) {
               symbols += "A";
            } else if (r == 11) {
               symbols += "B";
            } else if (r == 12) {
               symbols += "C";
            } else if (r == 13) {
               symbols += "D";
            } else if (r == 14) {
               symbols += "E";
            } else if (r == 15) {
               symbols += "F";
            }
            z -= (int) z;
            z *= base;
            counter++;
         }
      }      
      return negative? "-" + symbols : symbols;
   }

   /** Returns <i>n</i> as a hexadecimal string in 2-byte form.
    *  @param n the decimal number to be represented in a 2 byte hexadecimal form.
    *  @return string representing the hexadecimal representation of n
    */
   public static String decToHex2Byte(long n) {
      boolean negative = false;

      if (n < 0) {
         negative = true;
         n = -n;
      }

      String result = decToHex(n);

      while (result.length() % 4 != 0) {
         result = "0" + result;
      }
      if (negative) result = "-" + result;
      return result;
   }

   /** Returns a hexadecimal string as a binary string.
    *  @param hex the hexadecimal string to be represented in decimal form.
    *  @return the binary string representing the hexadecimal string
    *  @throws NumberFormatException if the string is not hexadecimal
    */
   public static String hexToBin(String hex) {
      String bin = "";
      char symbol;
      for (int i = 0; i < hex.length(); i++) {
         symbol = hex.charAt(i);
         if (symbol == '.' || symbol == ',') {
            bin += ".";
         } else if (symbol == '0') {
            bin += "0000";
         } else if (symbol == '1') {
            bin += "0001";
         } else if (symbol == '2') {
            bin += "0010";
         } else if (symbol == '3') {
            bin += "0011";
         } else if (symbol == '4') {
            bin += "0100";
         } else if (symbol == '5') {
            bin += "0101";
         } else if (symbol == '6') {
            bin += "0110";
         } else if (symbol == '7') {
            bin += "0111";
         } else if (symbol == '8') {
            bin += "1000";
         } else if (symbol == '9') {
            bin += "1001";
         } else if (symbol == 'A' || symbol == 'a') {
            bin += "1010";
         } else if (symbol == 'B' || symbol == 'b') {
            bin += "1011";
         } else if (symbol == 'C' || symbol == 'c') {
            bin += "1100";
         } else if (symbol == 'D' || symbol == 'd') {
            bin += "1101";
         } else if (symbol == 'E' || symbol == 'e') {
            bin += "1110";
         } else if (symbol == 'F' || symbol == 'f') {
            bin += "1111";
         } else {
            throw new NumberFormatException("No hexadecimal: "+hex);
         }
      }
      return bin;
   }

   /** Returns a hexadecimal string as a decimal integer.
    *  @param hex the hexadecimal string to be represented in decimal form.
    *  @return the long integer representing the hexadecimal string
    *  @throws NumberFormatException if the string is not hexadecimal
    */
   public static long hexToDec(String hex) {
      return Long.parseLong(hex, 16);
      /*
      int base = 16;
      boolean negative = false;
      String symbol;
      int a_i = 0;
      long n = 0L;
      
      if (hex.substring(0,1).equals("-")) {
        negative = true;
        hex = hex.substring(1);
      }
      if (hex.substring(hex.length()-1, hex.length()).equals("-")) {
        negative = true;
        hex = hex.substring(0,hex.length() - 1);
      }
      
      for (int i = 0; i < hex.length(); i++) {
        symbol = hex.substring(i, i+1);
        try {
           a_i = Integer.parseInt(symbol);
        } catch (NumberFormatException nfe) {
           if (symbol.equalsIgnoreCase("A")) {
              a_i = 10;
           } else if (symbol.equalsIgnoreCase("B")) {
              a_i = 11;
           } else if (symbol.equalsIgnoreCase("C")) {
              a_i = 12;
           } else if (symbol.equalsIgnoreCase("D")) {
              a_i = 13;
           } else if (symbol.equalsIgnoreCase("E")) {
              a_i = 14;
           } else if (symbol.equalsIgnoreCase("F")) {
              a_i = 15;
           } else {
              throw new NumberFormatException ("No hexadecimal number");
           }
        }
        n += a_i * pow(base,hex.length() - i - 1);
      }
      
      if (negative)  n = -n;
      return n;
      */
   }
   
   /** Returns a hexadecimal string as a decimal floating-point number.
    *  @param hex the hexadecimal string to be represented in decimal form.
    *  @return the long integer representing the hexadecimal string
    *  @throws NumberFormatException if the string is not hexadecimal
    */
   public static double hexToDouble(String hex) {
      int base = 16;
      boolean negative = false;
      String symbol;
      double a_i, x;
      int point; // position of hexadecimal point
      
      if (hex.substring(0,1).equals("-")) {
        negative = true;
        hex = hex.substring(1);
      }
      if (hex.substring(hex.length()-1, hex.length()).equals("-")) {
        negative = true;
        hex = hex.substring(0,hex.length() - 1);
      }
      
      point = hex.indexOf('.');

      if (point == -1) {  // the string represents an integer!
         return negative? -hexToDec(hex) : hexToDec(hex);
      }
      
      x = hexToDec(hex.substring(0,point));
            
      hex = hex.substring(point+1, hex.length());
      
      for (int i = 0; i < hex.length(); i++) {
        symbol = hex.substring(i, i+1);
        try {
           a_i = Double.parseDouble(symbol); //Integer.parseInt(symbol);
        } catch (NumberFormatException nfe) {
           if (symbol.equalsIgnoreCase("A")) {
              a_i = 10;
           } else if (symbol.equalsIgnoreCase("B")) {
              a_i = 11;
           } else if (symbol.equalsIgnoreCase("C")) {
              a_i = 12;
           } else if (symbol.equalsIgnoreCase("D")) {
              a_i = 13;
           } else if (symbol.equalsIgnoreCase("E")) {
              a_i = 14;
           } else if (symbol.equalsIgnoreCase("F")) {
              a_i = 15;
           } else {
              throw new NumberFormatException ("No hexadecimal number");
           }
        }
        x += a_i / pow(base, i+1);
      }
      
      if (negative)  x = -x;
      return x;
   }
   
   /** Returns the Gray code of an integer <i>x</i>, with a given minimum length.
    *  If the minimum length is greater than the bit length of the integer <i>x</i>,
    *  the Gray code string is padded with leading zeros.
    *  @param x an integer
    *  @param minimumLength the minimum length of the returned Gray code string
    *  @return the Gray code of <i>x</i> as a string
    */
   public static String grayCode(long x, int minimumLength) {
      String out = grayCode(x);
      // pad with zeros:
      for (int i = out.length(); i < minimumLength; i++) {
         out = "0" + out;
      }
      return out;
   }
   
   /** Returns the Gray code of an integer.
    *  @param x an integer
    *  @return the Gray code of <i>x</i> as a string
    */
   public static String grayCode(long x) {
      return Long.toBinaryString(x^(x >> 1));
   }
   
   /** Returns the integer represented by a Gray code string.
    *  @param grayCode a Gray code string
    *  @return the integer represented by the Gray code string
    *  @throws NumberFormatException if the Gray code string does not contain a parsable long
    */
   public static long grayCodeToLong(String grayCode) {
      long x = Long.parseLong(grayCode,2), y = 0;
      for(int i = grayCode.length() - 1; i >= 0; i--) {
         y += ((y & (1 << i+1)) >> 1) ^ (x & (1 << i));
         //System.out.println("x_"+i+"="+(x & (1 << i))+", y="+Long.toBinaryString(y));
      }
      return y;
      /* // Ist auch richtig(!): --------------------------
      char[] gray = grayCode.toCharArray();
      char[] binary = new char[gray.length];
      binary[0] = gray[0];
      for (int i = 1; i < gray.length; i++) {
         binary[i] = binary[i-1] == gray[i] ? '0' : '1';
      }
      return Long.parseLong(String.valueOf(binary), 2);
      */ // -----------------------------------------------
   }

   /** Returns binary representation of the integer in which is represented by a Gray code string.
    *  @param grayCode a Gray code string
    *  @param minimumLength the minimum length of the returned Gray code string
    *  @return the binary representation of the integer represented by the Gray code string
    *  @throws NumberFormatException if the string does not represent a Gray code
    *  @see #grayCodeToBinary(String)
    */
   public static String grayCodeToBinary(String grayCode, int minimumLength) {
      String out = decToBin(grayCodeToLong(grayCode));
      // pad with zeros:
      for (int i = out.length(); i < minimumLength; i++) {
         out = "0" + out;
      }
      return out;
   }
   
   /** Returns binary representation of the integer in which is represented by a Gray code string.
    *  @param grayCode a Gray code string
    *  @return the binary representation of the integer represented by the Gray code string
    *  @throws NumberFormatException if the string does not represent a Gray code
    *  @see #grayCodeToBinary(String, int)
    */
   public static String grayCodeToBinary(String grayCode) {
      return decToBin(grayCodeToLong(grayCode));
   }
   
   /*
   public static void main(String[] args) {
      long time = System.nanoTime(); //.currentTimeMillis();
      int z = 10;//for (int z = 20; x <= 50; x++)
         //System.out.println(z+": "+partitions(z).size()+" <-> "+numberOfPartitions(z)[z]);
      partitions(z);
      //time = System.currentTimeMillis() - time;
      time = System.nanoTime() - time;
      System.out.println("Running time of partitions("+z+"): "+time/1000+" msec");
      System.exit(0);
      //--- linear Diophantine equation:
      //long a = 221, b = -247, c = 91;
      //long[] x_ = Numbers.solveLinearDiophantine(a, b, c);
      //System.out.println("(x_0,y_0) = ("+x_[1]+","+x_[2]+")");
      //System.out.print("(x,y) = ");
      //System.out.print("("+x_[1]+" - ("+b/x_[0]+") t, ");
      //System.out.println(x_[2]+" + "+a/x_[0]+" t)");
      //int t = -3;
      //System.out.println("For instance t="+t+": (x,y) = ("+(x_[1]-b*t/x_[0])+","+(x_[2]+a*t/x_[0])+")");
      //System.exit(0);
      //--- Bernoulli numbers: --------------
      //int n = 12;
      //System.out.println("B_"+n+" = "+ bernoulli(n));
      //--- Bernoulli numbers ---------------
      // //java.math.BigInteger[] p = numberOfPartitions(-50);
      // //for (int n=0; n < p.length; n++) {
      // //   System.out.println("p("+n+") = "+p[n]);
      // //}
      // boolean prime;
      // //long m = 1234567891L * 1234567891L; // needs about 30 sec
      // long m = 1234567891L; // needs 1 ms
      // long time = System.currentTimeMillis();
      // prime = isPrime(m);
      // time = System.currentTimeMillis() - time;
      // System.out.println(m + " prime? " + prime + " (running time: " + time + "ms)");
      // long[] y = euclid(21, 35);
      // //for(long n : y) {
      // //   System.out.print(n + ", ");
      // //}
      // System.out.println();
      // long n = 19876543210L;
      // m = 12345678901L;
      // System.out.println("5 mod 3="+mod(5,3)+", -5 mod 3="+mod(-5,3)+", 5 mod -3="+mod(5,-3)+", -5 mod -3 ="+mod(-5,-3));
//      long x = 5L;
//      long e = 3;
//      long n = 7L;
//      System.out.println(x + "^" + e + " mod " + n + " = "+modPow(x,e,n));
//      x = -5L;
//      e = 3;
//      n = 7L;
//      System.out.println(x + "^" + e + " mod " + n + " = "+modPow(x,e,n));
//      x = 5L;
//      e = -3;
//      n = 7L;
//      System.out.println(x + "^" + e + " mod " + n + " = "+modPow(x,e,n));
//      x = 5L;
//      e = 3;
//      n = -7L;
//      System.out.println(x + "^" + e + " mod " + n + " = "+modPow(x,e,n));

      // double x = PI;
      // long e = 3l;
      // double n = 7;
      // double y = mod(pow(x, e),n);
      // System.out.println(x + "^" + e + " mod " + n + " = " + modPow(x, e, n) + ", y="+y);
      // x = -15L;
      // e = 3;
      // n = 7L;
      // y = mod(pow(x, e),n);
      // System.out.println(x + "^" + e + " mod " + n + " = " + modPow(x, e, n) + ", y="+y);
      // x = 5L;
      // e = -3;
      // n = 7L;
      // y = mod(pow(x, e),n);
      // System.out.println(x + "^" + e + " mod " + n + " = " + modPow(x, e, n) + ", y="+y);
      // x = 5L;
      // e = 3;
      // n = -7L;
      // y = mod(pow(x, e),n);
      // System.out.println(x + "^" + e + " mod " + n + " = " + modPow(x, e, n) + ", y="+y);

      // /*
      // for (long n = -14; n <= 14; n++) {
         // //String s = decToTern(n);
         // //System.out.println(n + " = " + s + " = " + ternToDec(s));
         // //s = decToTern(n, 6);
         // //System.out.println(n + " = " + s + " = " + ternToDec(s));
         // 
         // String hex = decToHex(n);
         // //System.out.println(n + " = " + hex + " = " + hexToDec(hex));
         // hex = decToHex2Byte(n);
         // System.out.println(n + " = " + hex + " = " + hexToDec(hex));
      // }
      //System.out.println(ternBToDec("pq0qqp"));
      for (double x = -.5; x <= -1.5; x += 0.07) {
         String s = decToTern(x);
         System.out.println(x + " = " + s + " = " + ternToDouble(s));
      }
      String m = "-222.021", n = "22.21";
      //String m = "-01.021", n = "11.21";
      System.out.println(m);
      System.out.println(n);
      System.out.println(add3(m,n));
      System.out.println(ternToDouble(m) + "+"+ternToDouble(n) + "=" + ternToDouble(add3(m,n)));
      
      System.exit(0);
      System.out.println(ternBToDouble("n0p") + " = " + ternBToDec("n0p"));
      System.out.println(ternBToDouble("0.0000000000000000000000n0p"));
      double x = 4.643858133321702E-19;
      System.out.println(decToTernB(x, 40));
      System.out.println(x - ternBToDouble(decToTernB(x, 40)));
      String s;
      //s = "210.0201020000";
      //System.out.println(s + " = " + ternToTernB(s));
      s = "0.201";
      System.out.println(s + " = " + ternToTernB(s));
      s = "0201";
      System.out.println(s + " = " + ternToTernB(s));
      s = "0.02200220";
      System.out.println(s + " = " + ternToTernB(s));

      System.out.println(PI + " = " + decToTern(PI) + " = " + ternToTernB(decToTern(PI)));
      //System.out.println(ternToTernB("000210"));
      //System.out.println(ternToTernB("0.0201020000"));
      //System.out.println(ternToTernB("210.020102"));
   }
   // */
}
